<?xml version="1.0" encoding="UTF-8"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="expath-binary">
    <description>Tests for the extension functions in the EXPath "binary" package. Note the tests
        are written on the assumption that the "working directory" for resolving relative filenames
        is the directory containing this test catalog file.</description>
   <!--Autogenerated from file:/C:/Users/jwl/Saxonica/saxon/tests/qt3extra/expath/binary/binary.xml at 2013-08-27T13:00:54.461+01:00-->
    <link type="spec" document="http://expath.org/spec/binary"/>


    <environment name="binary">
        <namespace prefix="bin" uri="http://expath.org/ns/binary"/>
        <namespace prefix="binJAVA" uri="java:org.expath.ns.binary.EXPathBinary"/>
        <namespace prefix="err" uri="http://expath.org/ns/binary"/>
        <param name="empty.bin" select="xs:base64Binary('')"/>
        <!-- 'Man' in base64 - 3 octets, 4 characters -->
        <param name="man.base" select="xs:base64Binary('TWFu')"/>
        <param name="man.octets" select="77,97,110"/>
    </environment>

    <test-case name="binary-length-001">
        <description>Use length on an empty value</description>
        <created by="Michael Kay" on="2013-07-11"/>
        <environment ref="binary"/>
        <test> bin:length(xs:base64Binary("")) </test>
        <result>
            <assert-eq>0</assert-eq>
        </result>
    </test-case>
    <test-case name="binary-length-002">
        <description>Use length on an quadruple octet value</description>
        <created by="John Lumley" on="2013-07-16"/>
        <environment ref="binary"/>
        <test> bin:length(xs:base64Binary(xs:hexBinary("face1234"))) </test>
        <result>
            <all-of>
                <assert-type>xs:integer</assert-type>
                <assert-eq>4</assert-eq>
            </all-of>
        </result>
    </test-case>


    <test-case name="binary-from-octets-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a zero-length binary from an empty set of octets</description>
      <test> bin:from-octets(()) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-from-octets-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a 4-length binary from a triple of octets</description>
      <test> bin:from-octets($man.octets) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-from-octets-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Negative integer outside octet range in binary construction</description>
      <test> bin:from-octets((-77,97,110)) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}octet-out-of-range"/>
            </result>
   </test-case>
   <test-case name="binary-from-octets-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Positive integer outside octet range in binary construction</description>
      <test> bin:from-octets((277,97,110)) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}octet-out-of-range"/>
            </result>
   </test-case>

    <test-case name="binary-to-octets-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Octets from a zero-length binary</description>
      <test> bin:to-octets(xs:base64Binary("")) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-to-octets-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate octets from a 4-length</description>
      <test> bin:to-octets($man.base) </test>
      <result>
                <all-of>
                    <assert-type>xs:integer*</assert-type>
                    <assert-deep-eq>(77,97,110)</assert-deep-eq>
                </all-of>
            </result>
   </test-case>

    <test-case name="binary-hex-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a zero-length binary from an empty hex string</description>
      <test> bin:hex("") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-hex-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>hex - Generate an empty sequence from an empty sequence</description>
      <test> bin:hex(()) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-hex-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a binary from a two-multiple hex string</description>
      <test> bin:hex("4D616E") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFu")</assert-eq>
                    <assert-eq>xs:base64Binary(xs:hexBinary("4D616E"))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-hex-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a binary from a non-two-multiple hex string</description>
      <test> bin:hex("D616E") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("DWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-hex-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Parsing error in hex string</description>
      <test> bin:hex("4X616E") </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}non-numeric-character"/>
            </result>
   </test-case>
    <test-case name="binary-bin-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a zero-length binary from an empty binary string</description>
      <test> bin:bin("") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bin-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>bin - Generate an empty sequence from an empty sequence</description>
      <test> bin:bin(()) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-bin-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a binary from an eight-multiple binary string</description>
      <test> bin:bin("010011010110000101101110") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bin-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a binary from a non-eight-multiple binary string</description>
      <test> bin:bin("011010110000101101110") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("DWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bin-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Parsing error in binary string</description>
      <test> bin:bin("0100a1010110000101101110") </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}non-numeric-character"/>
            </result>
   </test-case>
    <test-case name="binary-octal-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a zero-length binary from an empty octal string</description>
      <test> bin:octal("") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-octal-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>octal - Generate an empty sequence from an empty sequence</description>
      <test> bin:octal(()) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-octal-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a binary from byte-aligned octal string</description>
      <test> bin:octal("23260556") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-octal-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Generate a binary from a non-byte-aligned string</description>
      <test> bin:octal("3260556") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("DWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-octal-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Parsing error in octal string</description>
      <test> bin:octal("8260556") </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}non-numeric-character"/>
            </result>
   </test-case>



    <!--Autogenerated from file:/C:/Users/jwl/Saxonica/saxon/tests/qt3extra/expath/binary/parts/basic-operations.xml at 2013-08-27T13:00:54.461+01:00--><test-case name="binary-part-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Part of an empty sequence</description>
      <test> bin:part((),0) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-part-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Part with negative offset</description>
      <test> bin:part($man.base,-1) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-part-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Part with negative size</description>
      <test> bin:part($man.base,0,-1) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-part-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Part: offset beyond end of input</description>
      <test> bin:part($man.base,3) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-part-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Part: end beyond end of input</description>
      <test> bin:part($man.base,2,2) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-join-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Join of an empty sequence</description>
      <test> bin:join(()) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-join-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Join of two sequences</description>
      <test> bin:join(($man.base,$man.base)) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFuTWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-join-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Join with type mismatch sequences</description>
      <test> bin:join(($man.base,123)) </test>
      <result>
                <error code="Q{http://www.w3.org/2005/xqt-errors.}XPTY0004"/>
            </result>
   </test-case>
   <test-case name="binary-insert-before-001">
      <created by="John Lumley" on="2013-08-06"/>
      <environment ref="binary"/>
      <description>Insert-before with an empty sequence</description>
      <test> bin:insert-before((),0,$man.base) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-insert-before-002">
      <created by="John Lumley" on="2013-08-06"/>
      <environment ref="binary"/>
      <description>Insert-before with negative offset</description>
      <test> bin:insert-before($man.base,-1,$man.base) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-insert-before-003">
      <created by="John Lumley" on="2013-08-06"/>
      <environment ref="binary"/>
      <description>Insert-before: offset beyond end of input</description>
      <test> bin:insert-before($man.base,4,$man.base) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-insert-before-004">
      <created by="John Lumley" on="2013-08-06"/>
      <environment ref="binary"/>
      <description>Insert-before with an empty extra</description>
      <test> bin:insert-before($man.base,0,()) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-insert-before-005">
      <created by="John Lumley" on="2013-08-06"/>
      <environment ref="binary"/>
      <description>Insert-before of two sequences</description>
      <test> bin:insert-before($man.base,0,$man.base) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFuTWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-insert-before-006">
      <created by="John Lumley" on="2013-08-06"/>
      <environment ref="binary"/>
      <description>Insert-before of two sequences</description>
      <test> bin:to-octets(bin:insert-before($man.base,2,$man.base)) </test>
      <result>
                <all-of>
                    <assert-deep-eq>(77,97,77,97,110,110)</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-left-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad left on an empty sequence</description>
      <test> bin:pad-left((),2) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-pad-left-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left with negative size</description>
      <test> bin:pad-left($man.base,-1) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-pad-left-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left with negative octet</description>
      <test> bin:pad-left($man.base,1,-3) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}octet-out-of-range"/>
            </result>
   </test-case>
   <test-case name="binary-pad-left-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left with large octet</description>
      <test> bin:pad-left($man.base,1,333) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}octet-out-of-range"/>
            </result>
   </test-case>
   <test-case name="binary-pad-left-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left with zero size</description>
      <test> bin:pad-left($man.base,0) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-string-value>TWFu</assert-string-value>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-left-006">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left by 3 octets</description>
      <test> bin:pad-left($man.base,3) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AAAATWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-left-007">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left by 1 octet</description>
      <test> bin:pad-left($man.base,1) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AE1hbg==")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-left-008">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-left by 1 octet with non-zero padding</description>
      <test> bin:to-octets(bin:pad-left($man.base,1,12)) </test>
      <result>
                <all-of>
                    <assert-type>xs:integer*</assert-type>
                    <assert-deep-eq>(12,77,97,110)</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-right-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad right on an empty sequence</description>
      <test> bin:pad-right((),2) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-pad-right-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right with negative size</description>
      <test> bin:pad-right($man.base,-1) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-pad-right-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right with negative octet</description>
      <test> bin:pad-right($man.base,1,-3) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}octet-out-of-range"/>
            </result>
   </test-case>
   <test-case name="binary-pad-right-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right with large octet</description>
      <test> bin:pad-right($man.base,1,333) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}octet-out-of-range"/>
            </result>
   </test-case>
   <test-case name="binary-pad-right-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right with zero size</description>
      <test> bin:pad-right($man.base,0) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFu")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-right-006">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right by 3 octets</description>
      <test> bin:pad-right($man.base,3) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFuAAAA")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-right-007">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right by 1 octet</description>
      <test> bin:pad-right($man.base,1) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("TWFuAA==")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pad-right-008">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>Pad-right by 1 octet with non-zero padding</description>
      <test> bin:to-octets(bin:pad-right($man.base,1,12)) </test>
      <result>
                <all-of>
                    <assert-type>xs:integer*</assert-type>
                    <assert-deep-eq>(77,97,110,12)</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-find-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find on an empty sequence</description>
      <test> bin:find((),0,xs:base64Binary("TWFuAAAA")) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-find-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find with an empty search sequence</description>
      <test> bin:find(xs:base64Binary("TWFuAAAA"),0,xs:base64Binary("")) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}empty-search-item"/>
            </result>
   </test-case>
   <test-case name="binary-find-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find with negative offset</description>
      <test> bin:find(xs:base64Binary("AE1hbg=="),-1,xs:base64Binary("TWFu")) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-find-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find with offset beyond input</description>
      <test> bin:find(xs:base64Binary("AE1hbg=="),5,xs:base64Binary("TWFu")) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-find-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find with search sequence absent from target</description>
      <test> bin:find(xs:base64Binary("AE1hbg=="),2,xs:base64Binary("TWFu")) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-find-006">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find under normal operation</description>
      <test> bin:find(xs:base64Binary("AE1hbg=="),0,xs:base64Binary("TWFu")) </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-find-007">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>find under normal operation</description>
      <test> bin:find(xs:base64Binary("TWFuAA=="),0,xs:base64Binary("TWFu")) </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>0</assert-eq>
                </all-of>
            </result>
   </test-case>
    <!--Autogenerated from file:/C:/Users/jwl/Saxonica/saxon/tests/qt3extra/expath/binary/parts/text-encoding.xml at 2013-08-27T13:00:54.461+01:00--><test-case name="binary-encode-string-001">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>encode-string on an empty string</description>
      <test> bin:encode-string("","utf-8") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-encode-string-002">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>encode-string with unknown encoding</description>
      <test> bin:encode-string("","NOTutf-8") </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-encoding"/>
            </result>
   </test-case>
   <test-case name="binary-encode-string-003">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>encode-string on a non-empty string</description>
      <test> bin:encode-string("AêñüC","utf-8") </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("QcOqw7HDvEM=")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-encode-string-004">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>encode-string on a non-empty string, converted to octets</description>
      <test> bin:to-octets(bin:encode-string("AêñüC","utf-8")) </test>
      <result>
                <assert-deep-eq>(65,195,170,195,177,195,188,67)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-encode-string-005">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>encode-string on a non-empty string - UTF-16 - no control over
                BOM</description>
      <test> xs:hexBinary(bin:encode-string("This is UTF-16","utf-16")) </test>
      <result>
                <assert-eq>xs:hexBinary("feff00540068006900730020006900730020005500540046002d00310036")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-encode-string-006">
      <created by="John Lumley" on="2013-07-18"/>
      <environment ref="binary"/>
      <description>encode-string on a non-empty string - UTF-16 - no control over
                BOM</description>
      <test> xs:hexBinary(bin:encode-string("Ğ","utf-16")) </test>
      <result>
                <assert-eq>xs:hexBinary("feff011e")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-decode-string-001">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on an empty sequence</description>
      <test> bin:decode-string((),"utf-8") </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-decode-string-002">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on empty binary data</description>
      <test> bin:decode-string($empty.bin,"utf-8") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>""</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-003">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with unknown encoding</description>
      <test> bin:decode-string($empty.bin,"NOTutf-8") </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-encoding"/>
            </result>
   </test-case>
   <test-case name="binary-decode-string-004">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on non-empty binary data</description>
      <test> bin:decode-string(bin:encode-string("Simple £ text","utf-8"),"utf-8") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"Simple £ text"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-005">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on non-empty binary data</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"AêñüC"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-006">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on non-empty binary data, converted from octets</description>
      <test> bin:decode-string(bin:from-octets((65,195,170,195,177,195,188,67)),"utf-8") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"AêñüC"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-007">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with offset</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8",3) </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"ñüC"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-008">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with offset and size</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8",3,4) </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"ñü"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-009">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with negative offset</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8",-3,4) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-decode-string-010">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with negative size</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8",3,-4) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-decode-string-011">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with offset+size beyond data</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8",3,6) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-decode-string-012">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string with code phasing mismatch in UTF-8</description>
      <test> bin:decode-string(xs:base64Binary("QcOqw7HDvEM="),"utf-8",2) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}decoding-error"/>
            </result>
   </test-case>
   <test-case name="binary-decode-string-013">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on non-empty binary data in UTF-16</description>
      <test>
                bin:decode-string(xs:base64Binary(xs:hexBinary("feff00540068006900730020006900730020005500540046002d00310036")),"utf-16") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"This is UTF-16"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-014">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on non-empty binary data in UTF-16 with big-endian BOM</description>
      <test> bin:decode-string(xs:base64Binary(xs:hexBinary("feff011e")),"utf-16") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"Ğ"</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-decode-string-015">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary"/>
      <description>decode-string on non-empty binary data in UTF-16 with little endian
                BOM</description>
      <test> bin:decode-string(xs:base64Binary(xs:hexBinary("fffe1e01")),"utf-16") </test>
      <result>
                <all-of>
                    <assert-type>xs:string</assert-type>
                    <assert-eq>"Ğ"</assert-eq>
                </all-of>
            </result>
   </test-case>
    <!--Autogenerated from file:/C:/Users/jwl/Saxonica/saxon/tests/qt3extra/expath/binary/parts/numeric-packing.xml at 2013-08-27T13:00:54.461+01:00--><environment name="binary.numeric">
        <namespace prefix="bin" uri="http://expath.org/ns/binary"/>
        <namespace prefix="binJAVA" uri="java:org.expath.ns.binary.EXPathBinary"/>
        <namespace prefix="err" uri="http://expath.org/ns/binary"/>
        <param name="int.byte" select="5"/>
        <param name="int.short" select="256 * 1 + 5"/>
        <param name="int.3" select="65536 * 1 + 256 * 1 + 5"/>
        <param name="int.int" select="16777216 * 1 + 65536 * 1 + 256 * 1 + 5"/>
        <param name="int.long"
             select="4294967296 * 1 + 16777216 * 1 + 65536 * 1 + 256 * 1 + 5"/>
        <param name="double.negative.0"
             select="xs:base64Binary(xs:hexBinary('8000000000000000'))"/>
        <param name="double.1"
             select="xs:base64Binary(xs:hexBinary('3ff0000000000000'))"/>
        <param name="double.1.octets" select="(63,240,0,0,0,0,0,0)"/>
        <param name="float.negative.0"
             select="xs:base64Binary(xs:hexBinary('80000000'))"/>
        <param name="float.1.octets" select="(63,128,0,0)"/>
        <param name="int.byte.B" select="xs:base64Binary(xs:hexBinary('f0'))"/>
        <param name="int.short.B" select="xs:base64Binary(xs:hexBinary('f040'))"/>
        <param name="int.short.B-1" select="xs:base64Binary(xs:hexBinary('ffff'))"/>
    </environment>
   <test-case name="binary-pack-integer-001">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with unknown octet-order</description>
      <test> bin:pack-integer(0,1,'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-002">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer octet-order comparison - most significant
                synonyms</description>
      <test> for $b in bin:pack-integer(34567,3,'most-significant-first') return $b eq
                bin:pack-integer(34567,3,'big-endian') and $b eq bin:pack-integer(34567,3,'BE') </test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-003">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer octet-order comparison - least significant
                synonyms</description>
      <test> for $b in bin:pack-integer(34567,3,'least-significant-first') return $b eq
                bin:pack-integer(34567,3,'little-endian') and $b eq bin:pack-integer(34567,3,'LE') </test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-004">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer octet-order comparison - least and most differ</description>
      <test> bin:pack-integer(34567,3,'most-significant-first') eq
                bin:pack-integer(34567,3,'least-significant-first') </test>
      <result>
                <assert-false/>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-005">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with negative length</description>
      <test> bin:pack-integer(34567,-3,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-006">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with zero length</description>
      <test> bin:pack-integer(34567,0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-007">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with zero as byte</description>
      <test> bin:pack-integer(0,1) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AA==")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-008">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as byte</description>
      <test> bin:pack-integer($int.short,1) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("BQ==")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-009">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with zero as short</description>
      <test> bin:pack-integer(0,2) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AAA=")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-010">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as short - default - big-endian</description>
      <test> bin:pack-integer($int.short,2) eq  bin:pack-integer($int.short,2,'BE')</test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-011">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as short - little-endian</description>
      <test> bin:pack-integer($int.short,2,'least-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("BQE=")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-012">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as short - big-endian</description>
      <test> bin:pack-integer($int.short,2,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AQU=")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-013">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as short - big-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.short,2)) </test>
      <result>
                <assert-deep-eq>(1,5)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-014">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as short - big-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.short,2,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(1,5)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-015">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as 3-byte - little-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.3,3,'LE')) </test>
      <result>
                <assert-deep-eq>(5,1,1)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-016">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as 3-byte - big-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.3,3,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(1,1,5)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-017">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as int - little-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.int,4,'LE')) </test>
      <result>
                <assert-deep-eq>(5,1,1,1)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-018">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as int - big-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.int,4,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(1,1,1,5)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-019">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as long - little-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.long,8,'LE')) </test>
      <result>
                <assert-deep-eq>(5,1,1,1,1,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-020">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as long - big-endian</description>
      <test> bin:to-octets(bin:pack-integer($int.long,8,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(0,0,0,1,1,1,1,5)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-integer-021">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-integer with non-zero as BIG - big-endian</description>
      <test> bin:to-octets(bin:pack-integer(12345678901234,12,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(0, 0, 0, 0, 0, 0, 11, 58, 115, 206, 47, 242)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-001">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with unknown octet-order</description>
      <test> bin:pack-double(xs:double(0.0),'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-pack-double-002">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with 0.0 - little endian</description>
      <test> bin:pack-double(xs:double(0.0)) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AAAAAAAAAAA=")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-double-003">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with +0.0 - big-endian. Note the difference from IEEE regarding
                no negative zero - in that case the leading octet is 128</description>
      <test> bin:to-octets(bin:pack-double(+xs:double(0.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(0,0,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-004">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with -0.0 - big-endian. Note the difference from IEEE regarding
                no negative zero - in that case the leading octet is 128</description>
      <test> bin:to-octets(bin:pack-double(-xs:double(0.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(128,0,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-005">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with 1.0 - little-endian</description>
      <test> bin:to-octets(bin:pack-double(xs:double(1.0),'LE')) </test>
      <result>
                <assert-deep-eq>(0,0,0,0,0,0,240,63)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-006">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with 1.0 - big-endian</description>
      <test> bin:to-octets(bin:pack-double(xs:double(1.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(63,240,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-007">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with 1.0 - big-endian</description>
      <test> bin:pack-double(xs:double(1.0),'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary('3ff0000000000000'))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-double-008">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with 2.0 - big-endian</description>
      <test> bin:to-octets(bin:pack-double(xs:double(2.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(64,0,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-009">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with positive infinity - big-endian</description>
      <test> bin:to-octets(bin:pack-double(1 div 0e0,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,240,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-010">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with negative infinity - big-endian</description>
      <test> bin:to-octets(bin:pack-double(-1 div 0e0,'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(255,240,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-double-011">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-double with NaN - big-endian. Possibilities of other NaN
                values?</description>
      <test> bin:to-octets(bin:pack-double(number("NaN"),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,248,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-001">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with unknown octet-order</description>
      <test> bin:pack-float(xs:float(0.0),'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-pack-float-002">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with 0.0 - little endian</description>
      <test> bin:pack-float(xs:float(0.0)) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary("AAAAAA==")</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-pack-float-003">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with +0.0 - big-endian. Note the difference from IEEE regarding
                no negative zero - in that case the leading octet is 128</description>
      <test> bin:to-octets(bin:pack-float(+xs:float(0.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-004">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with -0.0 - big-endian. Note the difference from IEEE regarding
                no negative zero - in that case the leading octet is 128</description>
      <test> bin:to-octets(bin:pack-float(-xs:float(0.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(128,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-005">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with 1.0 - little-endian</description>
      <test> bin:to-octets(bin:pack-float(xs:float(1.0),'LE')) </test>
      <result>
                <assert-deep-eq>(0,0,128,63)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-006">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with 1.0 - big-endian</description>
      <test> bin:to-octets(bin:pack-float(xs:float(1.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(63,128,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-007">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with 2.0 - big-endian</description>
      <test> bin:to-octets(bin:pack-float(xs:float(2.0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(64,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-008">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with positive infinity - big-endian</description>
      <test> bin:to-octets(bin:pack-float(xs:float(1 div 0e0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,128,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-009">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with negative infinity - big-endian</description>
      <test> bin:to-octets(bin:pack-float(xs:float(-1 div 0e0),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(255,128,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-pack-float-010">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>pack-float with NaN - big-endian. Possibilities of other NaN
                values?</description>
      <test> bin:to-octets(bin:pack-float(xs:float(number("NaN")),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,192,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-001">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double with unknown octet-order</description>
      <test> bin:unpack-double(bin:from-octets($double.1.octets),0,'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-002">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double with negative offset</description>
      <test> bin:unpack-double(bin:from-octets($double.1.octets),-1,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-003">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double extending beyond data</description>
      <test> bin:unpack-double(bin:from-octets($double.1.octets),1,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-004">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double for -0.0 - big-endian</description>
      <test> bin:unpack-double($double.negative.0,0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:double</assert-type>
                    <assert-eq>-0.0</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-005">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double for 1.0 - big-endian</description>
      <test> bin:unpack-double(bin:from-octets($double.1.octets),0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:double</assert-type>
                    <assert-eq>1.0</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-006">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double with NaN - big-endian</description>
      <test>
                bin:unpack-double(bin:from-octets((127,248,0,0,0,0,0,0)),0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:double</assert-type>
                    <assert-deep-eq>number("NaN")</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-007">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double with NaN with payload - big-endian</description>
      <test>
                bin:unpack-double(bin:from-octets((127,248,0,0,0,0,0,1)),0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:double</assert-type>
                    <assert-deep-eq>number("NaN")</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-008">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double with quiet NaN with payload - big-endian</description>
      <test>
                bin:to-octets(bin:pack-double(bin:unpack-double(bin:from-octets((127,248,0,0,0,0,0,1)),0,'most-significant-first'),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,248,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-unpack-double-009">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-double with signalling NaN with payload - big-endian</description>
      <test>
                bin:to-octets(bin:pack-double(bin:unpack-double(bin:from-octets((127,240,0,0,0,0,0,1)),0,'most-significant-first'),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,248,0,0,0,0,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-001">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float with unknown octet-order</description>
      <test> bin:unpack-float(bin:from-octets($float.1.octets),0,'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-002">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float with negative offset</description>
      <test> bin:unpack-float(bin:from-octets($float.1.octets),-1,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-003">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float extending beyond data</description>
      <test> bin:unpack-float(bin:from-octets($float.1.octets),1,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-004">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float for -0.0 - big-endian</description>
      <test> bin:unpack-float($float.negative.0,0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:float</assert-type>
                    <assert-eq>-0.0</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-005">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float for 1.0 - big-endian</description>
      <test> bin:unpack-float(bin:from-octets($float.1.octets),0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:float</assert-type>
                    <assert-eq>1.0</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-006">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float with NaN - big-endian</description>
      <test> bin:unpack-float(bin:from-octets((127,192,0,0)),0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:float</assert-type>
                    <assert-deep-eq>xs:float(number("NaN"))</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-007">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float with NaN with payload - big-endian</description>
      <test> bin:unpack-float(bin:from-octets((127,192,0,1)),0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:float</assert-type>
                    <assert-deep-eq>number("NaN")</assert-deep-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-008">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float with quiet NaN with payload - big-endian</description>
      <test>
                bin:to-octets(bin:pack-float(bin:unpack-float(bin:from-octets((127,192,0,1)),0,'most-significant-first'),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,192,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-unpack-float-009">
      <created by="John Lumley" on="2013-07-19"/>
      <environment ref="binary.numeric"/>
      <description>unpack-float with signalling NaN with payload - big-endian</description>
      <test>
                bin:to-octets(bin:pack-float(bin:unpack-float(bin:from-octets((127,248,0,1)),0,'most-significant-first'),'most-significant-first')) </test>
      <result>
                <assert-deep-eq>(127,192,0,0)</assert-deep-eq>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer with unknown octet-order</description>
      <test> bin:unpack-unsigned-integer($int.byte.B,0,1,'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer octet-order comparison - most significant
                synonyms</description>
      <test> for $b in bin:unpack-unsigned-integer($int.short.B,0,2,'most-significant-first')
                return $b eq bin:unpack-unsigned-integer($int.short.B,0,2,'big-endian') and $b eq
                bin:unpack-unsigned-integer($int.short.B,0,2,'BE') </test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-003">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer octet-order comparison - least significant
                synonyms</description>
      <test> for $b in bin:unpack-unsigned-integer($int.short.B,0,2,'least-significant-first')
                return $b eq bin:unpack-unsigned-integer($int.short.B,0,2,'little-endian') and $b eq
                bin:unpack-unsigned-integer($int.short.B,0,2,'LE') </test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-004">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer octet-order comparison - least and most
                differ</description>
      <test> bin:unpack-unsigned-integer($int.short.B,0,2,'most-significant-first') eq
                bin:unpack-unsigned-integer($int.short.B,0,2,'least-significant-first') </test>
      <result>
                <assert-false/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-005">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer with negative offset</description>
      <test> bin:unpack-unsigned-integer($int.short.B,-1,2,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-006">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer with negative length</description>
      <test> bin:unpack-unsigned-integer($int.short.B,0,-2,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-007">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer extending beyond data</description>
      <test> bin:unpack-unsigned-integer($int.short.B,1,2,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-008">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer with zero length </description>
      <test> bin:unpack-unsigned-integer($int.byte.B,0,0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>0</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-009">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer on byte </description>
      <test> bin:unpack-unsigned-integer($int.byte.B,0,1,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>240</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-010">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer on short </description>
      <test> bin:unpack-unsigned-integer($int.short.B,0,2,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>61504</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-011">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer on long </description>
      <test>
                bin:unpack-unsigned-integer(xs:base64Binary(xs:hexBinary('0000000000000001')),0,8,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-012">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer on long </description>
      <test>
                bin:unpack-unsigned-integer(xs:base64Binary(xs:hexBinary('ffffffffffffffff')),0,8,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>-1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-013">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer on BIG </description>
      <test>
                bin:unpack-unsigned-integer(xs:base64Binary(xs:hexBinary('0fffffffffffffffffff')),0,10,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>75557863725914323419135</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-unsigned-integer-014">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-unsigned-integer on BIG </description>
      <test>
                bin:unpack-unsigned-integer(xs:base64Binary(xs:hexBinary('ffffffffffffffffffff')),0,10,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>1208925819614629174706175</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer with unknown octet-order</description>
      <test> bin:unpack-signed-integer($int.byte.B,0,1,'MOST-sign-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}unknown-significance-order"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer octet-order comparison - most significant
                synonyms</description>
      <test> for $b in bin:unpack-signed-integer($int.short.B,0,2,'most-significant-first')
                return $b eq bin:unpack-signed-integer($int.short.B,0,2,'big-endian') and $b eq
                bin:unpack-signed-integer($int.short.B,0,2,'BE') </test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-003">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer octet-order comparison - least significant
                synonyms</description>
      <test> for $b in bin:unpack-signed-integer($int.short.B,0,2,'least-significant-first')
                return $b eq bin:unpack-signed-integer($int.short.B,0,2,'little-endian') and $b eq
                bin:unpack-signed-integer($int.short.B,0,2,'LE') </test>
      <result>
                <assert-true/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-004">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer octet-order comparison - least and most
                differ</description>
      <test> bin:unpack-signed-integer($int.short.B,0,2,'most-significant-first') eq
                bin:unpack-signed-integer($int.short.B,0,2,'least-significant-first') </test>
      <result>
                <assert-false/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-005">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer with negative offset</description>
      <test> bin:unpack-signed-integer($int.short.B,-1,2,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-offset"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-006">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer with negative length</description>
      <test> bin:unpack-signed-integer($int.short.B,0,-2,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}negative-size"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-007">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer extending beyond data</description>
      <test> bin:unpack-signed-integer($int.short.B,1,2,'most-significant-first') </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}offset-beyond-end"/>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-008">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer with zero length </description>
      <test> bin:unpack-signed-integer($int.byte.B,0,0,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>0</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-009">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on byte </description>
      <test> bin:unpack-signed-integer($int.byte.B,0,1,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>-16</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-010">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on short </description>
      <test> bin:unpack-signed-integer($int.short.B-1,0,2,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>-1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-011">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on short </description>
      <test>
                bin:unpack-signed-integer(xs:base64Binary(xs:hexBinary('0001')),0,2,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-012">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on short </description>
      <test> bin:unpack-signed-integer($int.short.B,0,2,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>-4032</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-013">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on short </description>
      <test> bin:unpack-signed-integer($int.short.B-1,0,2,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>-1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-014">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on long </description>
      <test>
                bin:unpack-signed-integer(xs:base64Binary(xs:hexBinary('0000000000000001')),0,8,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>1</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-unpack-signed-integer-015">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary.numeric"/>
      <description>unpack-signed-integer on long </description>
      <test>
                bin:unpack-signed-integer(xs:base64Binary(xs:hexBinary('ffffffffffffffff')),0,8,'most-significant-first') </test>
      <result>
                <all-of>
                    <assert-type>xs:integer</assert-type>
                    <assert-eq>-1</assert-eq>
                </all-of>
            </result>
   </test-case>
    <!--Autogenerated from file:/C:/Users/jwl/Saxonica/saxon/tests/qt3extra/expath/binary/parts/bitwise.xml at 2013-08-27T13:00:54.461+01:00--><environment name="binary-bitwise">
        <namespace prefix="bin" uri="http://expath.org/ns/binary"/>
        <namespace prefix="binJAVA" uri="java:org.expath.ns.binary.EXPathBinary"/>
        <namespace prefix="err" uri="http://expath.org/ns/binary"/>
        <param name="empty.bin" select="xs:base64Binary('')"/>
        <param name="a" select="xs:base64Binary(xs:hexBinary('F00F'))"/>
        <param name="b" select="xs:base64Binary(xs:hexBinary('0FF0'))"/>
        <param name="c" select="xs:base64Binary(xs:hexBinary('0FABCD'))"/>
    </environment>
   <test-case name="binary-bitwise-or-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-or with differing lengths</description>
      <test> bin:or($a,$c) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}differing-length-arguments"/>
            </result>
   </test-case>
   <test-case name="binary-bitwise-or-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-or with similar lengths</description>
      <test> bin:or($a,$b) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary("FFFF"))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bitwise-and-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-and with differing lengths</description>
      <test> bin:and($a,$c) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}differing-length-arguments"/>
            </result>
   </test-case>
   <test-case name="binary-bitwise-and-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-and with similar lengths</description>
      <test> bin:and($a,$b) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary("0000"))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bitwise-xor-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-xor with differing lengths</description>
      <test> bin:xor($a,$c) </test>
      <result>
                <error code="Q{http://expath.org/ns/binary}differing-length-arguments"/>
            </result>
   </test-case>
   <test-case name="binary-bitwise-xor-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-xor with similar lengths</description>
      <test> bin:xor($a,$b) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary("FFFF"))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bitwise-not-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-not with empty data</description>
      <test> bin:not($empty.bin) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary(""))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bitwise-not-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-not with non-empty data</description>
      <test> bin:not($a) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary("0FF0"))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-001">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift on empty sequence</description>
      <test> bin:shift((),5) </test>
      <result>
                <assert-empty/>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-002">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift by 0 bits</description>
      <test> bin:shift($a,0) </test>
      <result>
                <all-of>
                    <assert-type>xs:base64Binary</assert-type>
                    <assert-eq>xs:base64Binary(xs:hexBinary("F00F"))</assert-eq>
                </all-of>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-003">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 1 bit</description>
      <test> xs:hexBinary(bin:shift($a,1)) </test>
      <result>

                <assert-eq>xs:hexBinary("E01E")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-004">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 4 bits</description>
      <test> xs:hexBinary(bin:shift($a,4)) </test>
      <result>

                <assert-eq>xs:hexBinary("00F0")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-005">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 8 bits</description>
      <test> xs:hexBinary(bin:shift($a,8)) </test>
      <result>

                <assert-eq>xs:hexBinary("0F00")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-006">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 9 bits</description>
      <test> xs:hexBinary(bin:shift($a,9)) </test>
      <result>

                <assert-eq>xs:hexBinary("1E00")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-007">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 12 bits</description>
      <test> xs:hexBinary(bin:shift($a,12)) </test>
      <result>

                <assert-eq>xs:hexBinary("F000")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-008">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 16 bits</description>
      <test> xs:hexBinary(bin:shift($a,16)) </test>
      <result>

                <assert-eq>xs:hexBinary("0000")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-009">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift left by 17 bits</description>
      <test> xs:hexBinary(bin:shift($a,17)) </test>
      <result>

                <assert-eq>xs:hexBinary("0000")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-010">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 1 bit</description>
      <test> xs:hexBinary(bin:shift($a,-1)) </test>
      <result>

                <assert-eq>xs:hexBinary("7807")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-011">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 4 bits</description>
      <test> xs:hexBinary(bin:shift($a,-4)) </test>
      <result>

                <assert-eq>xs:hexBinary("0F00")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-012">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 8 bits</description>
      <test> xs:hexBinary(bin:shift($a,-8)) </test>
      <result>

                <assert-eq>xs:hexBinary("00F0")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-013">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 9 bits</description>
      <test> xs:hexBinary(bin:shift($a,-9)) </test>
      <result>

                <assert-eq>xs:hexBinary("0078")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-014">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 12 bits</description>
      <test> xs:hexBinary(bin:shift($a,-12)) </test>
      <result>

                <assert-eq>xs:hexBinary("000F")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-015">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 16 bits</description>
      <test> xs:hexBinary(bin:shift($a,-16)) </test>
      <result>

                <assert-eq>xs:hexBinary("0000")</assert-eq>
            </result>
   </test-case>
   <test-case name="binary-bitwise-shift-016">
      <created by="John Lumley" on="2013-07-22"/>
      <environment ref="binary-bitwise"/>
      <description>bitwise-shift right by 17 bits</description>
      <test> xs:hexBinary(bin:shift($a,-17)) </test>
      <result>

                <assert-eq>xs:hexBinary("0000")</assert-eq>
            </result>
   </test-case>



</test-set>
