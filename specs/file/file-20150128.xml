<?xml version="1.0" encoding="UTF-8"?>

<?oxygen RNGSchema="http://expath.org/ns/xmlspec/xmlspec.rnc"?>

<spec role="editors-copy" xmlns:ex="http://expath.org/ns/xmlspec" ex:w3c="true">
   <header>
      <title>File Module</title>
      <w3c-designation>w3c-designation</w3c-designation>
      <w3c-doctype>EXPath Proposed Module</w3c-doctype>
      <pubdate>
         <day>30</day>
         <month>January</month>
         <year>2015</year>
      </pubdate>
      <publoc>
         <loc href="http://expath.org/spec/file/20150130"/>
      </publoc>
      <altlocs>
         <loc href="http://expath.org/spec/file/20150130.xml">XML</loc>
         <loc href="http://expath.org/spec/file/20150130/diff">Revision markup</loc>
      </altlocs>
      <latestloc>
         <loc href="http://expath.org/spec/file"/>
      </latestloc>
      <prevlocs>
         <loc href="http://expath.org/spec/file/20131203"/>
         <loc href="http://expath.org/spec/file/20120614"/>
         <loc href="http://expath.org/spec/file/20120517"/>
      </prevlocs>
      <authlist>
         <author role="editor">
            <name>Christian Grün</name>
            <affiliation>BaseX GmbH</affiliation>
         </author>
         <author role="editor">
            <name>Matthias Brantner</name>
            <affiliation>28msec GmbH</affiliation>
         </author>
         <author role="contrib">
            <name>Gabriel Petrovay</name>
            <affiliation>28msec GmbH</affiliation>
         </author>
      </authlist>
      <copyright>
         <p>Copyright © 2010-2013 Christian Grün, published by the <loc
               href="http://w3.org/community/expath/">EXPath Community Group</loc> under the <loc
               href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
               License Agreement (CLA)</loc>. A human-readable <loc
               href="http://www.w3.org/community/about/agreements/cla-deed/">summary</loc> is
            available.</p>
         <p>This specification was published by the <loc href="http://www.w3.org/community/expath/"
               >EXPath Community Group</loc>. It is not a W3C Standard nor is it on the W3C
            Standards Track. Please note that under the <loc
               href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
               License Agreement (CLA)</loc> there is a limited opt-out and other conditions apply.s
            Learn more about <loc href="http://www.w3.org/community/">W3C Community and Business
               Groups</loc>.</p>
      </copyright>
      <abstract>
         <p>This proposal provides a file system API for XPath. It defines extension functions to
            perform file system related operations such as listing, reading, or writing files or
            directories. It has been designed to be compatible with XQuery 1.0 and XSLT 2.0, as
            well as any other XPath 2.0 usage.</p>
      </abstract>
      <status>
         <p/>
      </status>
      <langusage>
         <language>en-US</language>
      </langusage>
      <revisiondesc>
         <p>revisiondesc</p>
      </revisiondesc>
   </header>
   <body>

      <!-- *************************************** Introduction ******************************* -->
      <div1 id="status">
        <head>Status of this document</head>
        <p>This document is in a final draft stage. Comments are welcomed at <loc
            href="mailto:public-expath@w3.org">public-expath@w3.org</loc> mailing list (<loc
            href="http://lists.w3.org/Archives/Public/public-expath/">archive</loc>).</p>
      </div1>

      <div1 id="intro">
         <head>Introduction</head>

         <div2 id="namespaces">
            <head>Namespace conventions</head>
            <p>The module defined by this document defines functions and errors in the
               namespace <code>http://expath.org/ns/file</code>. In this document, the
                  <code>file</code> prefix is bound to this namespace URI.</p>
            <p>The <code>output</code> prefix is bound to the namespace
               <code>http://www.w3.org/2010/xslt-xquery-serialization</code>. It is used
               to specify serialization parameters.</p>
         </div2>

         <div2 id="file-paths">
            <head>File Paths</head>
            <p>All file paths are specified as strings, and are resolved against the current working
               directory. An implementation must accept absolute and relative UNIX/Linux and Windows
               paths as well as absolute file URIs. Some examples: </p>
            <ulist>
               <item>
                  <p><code>C:\Test Dir\my file.xml</code>: An absolute path on Windows
                     platforms.</p>
               </item>
               <item>
                  <p><code>/Test Dir/my file.xml</code>: An absolute path on UNIX-based
                     platforms.</p>
               </item>
               <item>
                  <p><code>C:\\\Test Dir//\\my file.xml</code>: An absolute path on Windows
                     platforms that tolerates an arbitrary number of slashes and backslashes.</p>
               </item>
               <item>
                  <p><code>my file.xml</code>: A relative path, pointing to a file in the current
                     working directory.</p>
               </item>
               <item>
                  <p><code>file:///C:/Test%20Dir/my%20file.xml</code>: An absolute file URI on
                     Windows platforms.</p>
               </item>
               <item>
                  <p><code>file:///Test%20Dir/my%20file.xml</code>: An absolute path on UNIX-based
                     platforms.</p>
               </item>
            </ulist>
            <p>Before further processing, all paths are normalized to an implementation-defined
               representation (which usually is the representation of the underlying operating system).</p>
            <p>An implementation may choose to raise <bibref ref="errIP"/> if a path is invalid.</p>
            <p>If a function returns a string that refers to a directory,
               it will always be suffixed with the system-specific directory separator.</p>
            <p>The function <loc href="#pr.base-dir">file:base-dir</loc> can be used to
               resolve file operations against the directory of the base URI:</p>
            <eg>let $filename := "input.txt"
let $dir := file:base-dir()
let $path := concat($dir, $filename)
return file:read-text($path)</eg>
         </div2>

         <div2 id="exec">
            <head>Query Execution</head>
            <p>Some function are marked as ·nondeterministic·, which means they are not guaranteed to
               perform the same operations and produce identical results from repeated calls. A query
               processor must ensure that these functions are not relocated or pre-evaluated and that
               its results are not cached when compiling and evaluating the query and serializing
               its results.</p>
         </div2>

         <div2 id="error">
            <head>Error Management</head>
            <p>Error conditions are identified by a code (a <code>QName</code>). When such an error
               condition is reached during the execution of the function, a dynamic error is thrown,
               with the corresponding error code (as if the standard XPath function
                  <code>fn:error</code> had been called).</p>
            <p>Error codes are defined through the specification. The generic error
               <bibref ref="errIE"/> with an appropriate message is raised for I/O faults,
               or for specific errors caused by the underlying platform or programming language.</p>
            <p>For a list of specific errors see the "Summary of Error Conditions" section of this
               document.</p>
         </div2>
      </div1>

      <!-- *************************************** File properties **************************** -->

      <div1 id="props">
         <head>File Properties</head>

         <div2 id="pr.exists">
            <head><code>file:exists</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:exists</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:boolean</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Tests if the file or directory pointed by <code>$path</code> exists.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.is-dir">
            <head><code>file:is-dir</code></head>
            <eg><ex:function>file:is-dir</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:boolean</ex:type></eg>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Tests if <code>$path</code> points to a directory. On UNIX-based systems the root and
                   the volume roots are considered directories.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.is-file">
            <head><code>file:is-file</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:is-file</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:boolean</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Tests if <code>$path</code> points to a file.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.last-modified">
            <head><code>file:last-modified</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:last-modified</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:dateTime</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the last modification time of a file or directory.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                  <item><bibref ref="errNF"/> is raised if <code>$path</code> does not
                     exist.</item>
                  <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.size">
            <head><code>file:size</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:size</ex:function>($file as <ex:type>xs:string</ex:type>) as <ex:type>xs:integer</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
              <p>Returns the byte size of a file, or the value <code>0</code> for directories.</p>
              <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$path</code> does not
                    exist.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>
      </div1>

      <!-- *************************************** I/O Functions ****************************** -->
      <div1 id="in-out">
         <head>Input/Output</head>

         <div2 id="fn.append">
            <head><code>file:append</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:append</ex:function>($file as <ex:type>xs:string</ex:type>,
            $items as <ex:type>item()*</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:append</ex:function>($file as <ex:type>xs:string</ex:type>,
            $items as <ex:type>item()*</ex:type>,
            $params as <ex:type>element(output:serialization-parameters)</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Appends a sequence of items to a file. If the file pointed by <code>$file</code> does
                   not exist, a new file will be created.</p>
                <p><code>$params</code> controls the way the <code>$items</code> items are serialized.
                   The semantics of <code>$params</code> is the same as for the
                   <code>fn:serialize</code> function in <bibref ref="fo30"/>. This consists of an
                   <code>output:serialization-parameters</code> element whose format is defined in
                   <bibref ref="ser30"/>. In contrast to <code>fn:serialize,</code>
                   the encoding stage will not be skipped by this function.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.append-binary">
            <head><code>file:append-binary</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:append-binary</ex:function>($file as <ex:type>xs:string</ex:type>,
                   $value as <ex:type>xs:base64Binary</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Appends a Base64 item as binary to a file. If the file pointed by <code>$file</code>
                   does not exist, a new file will be created.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                   <item><bibref ref="errND"/> is raised if the parent directory of
                         <code>$file</code> does not exist.</item>
                   <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                      directory.</item>
                   <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.append-text">
            <head><code>file:append-text</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:append-text</ex:function>($file as <ex:type>xs:string</ex:type>,
                 $value as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:append-text</ex:function>($file as <ex:type>xs:string</ex:type>,
                 $value as <ex:type>xs:string</ex:type>,
                 $encoding as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Appends a string to a file. If the file pointed by <code>$file</code> does not exist,
                   a new file will be created.</p>
                <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
                      <code>UTF-8</code>.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or
                    not supported by the implementation.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.append-text-lines">
            <head><code>file:append-text-lines</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:append-text-lines</ex:function>($file as <ex:type>xs:string</ex:type>,
                       $values as <ex:type>xs:string*</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:append-text-lines</ex:function>($file as <ex:type>xs:string</ex:type>,
                       $lines as <ex:type>xs:string*</ex:type>,
                       $encoding as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Appends a sequence of strings to a file, each followed by the system-dependent
                   newline character. If the file pointed by <code>$file</code> does not exist, a new
                   file will be created.</p>
                <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
                      <code>UTF-8</code>.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or
                    not supported by the implementation.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.copy">
            <head><code>file:copy</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:copy</ex:function>($source as <ex:type>xs:string</ex:type>,
          $target as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Copies a file or a directory given a source and a target path/URI. The following
                   cases may occur if <code>$source</code> points to a file:</p>
                <ol type="a">
                   <li> if <code>$target</code> does not exist, it will be created.</li>
                   <li> if <code>$target</code> is a file, it will be overwritten.</li>
                   <li> if <code>$target</code> is a directory, the file will be created in that
                      directory with the name of the source file. If a file already exists, it will be
                      overwritten.</li>
                </ol>
                <p>The following cases may occur if <code>$source</code> points to a directory:</p>
                <ol type="a">
                   <li> if <code>$target</code> does not exist, it will be created as directory, and all
                      files of the source directory are copied to this directory with their existing
                      local names.</li>
                   <li> if <code>$target</code> is a directory, the source directory with all its files
                      will be copied into the target directory.  At each level, if a file already exists
                      in the target with the same name as in the source, it is overwritten.  If a directory
                      already exists in the target with the same name as in the source, it is not removed,
                      it is recursed in place (if it does not exist, it is created before recursing).</li>
                </ol>
                <p>Other cases will raise one of the errors listed below.</p>
                <p>The function returns the empty sequence if the operation is successful. If an error
                   occurs during the operation, no rollback to the original state will be possible </p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if the <code>$source</code> path does not
                    exist.</item>
                 <item><bibref ref="errE"/> is raised if <code>$source</code> points to a
                    directory and <code>$target</code> points to an existing file.</item>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$source</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$source</code> points to a file
                    and <code>$target</code> points to a directory, in which a subdirectory exists
                    with the name of the source file.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.create-dir">
            <head><code>file:create-dir</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:create-dir</ex:function>($dir as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Creates a directory, or does nothing if the directory already exists. The operation
                   will create all non-existing parent directories.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errE"/> is raised if the specified path, or any of its
                    parent directories, points to an existing file.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.create-temp-dir">
            <head><code>file:create-temp-dir</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:create-temp-dir</ex:function>($prefix as <ex:type>xs:string</ex:type>,
                     $suffix as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type>
<ex:function>file:create-temp-dir</ex:function>($prefix as <ex:type>xs:string</ex:type>,
                     $suffix as <ex:type>xs:string</ex:type>,
                     $dir as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Creates a temporary directory and all non-existing parent directories
                   and returns the full path to the created directory.</p>
                <p>The temporary directory will not be automatically deleted after query execution.
                   It is guaranteed to not already exist when the function is called.</p>
                <p>If <code>$dir</code> is not given, the directory will be created inside
                   the system-dependent default temporary-file directory.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the specified directory does
                    not exist or points to a file.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.create-temp-file">
            <head><code>file:create-temp-file</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:create-temp-file</ex:function>($prefix as <ex:type>xs:string</ex:type>,
                      $suffix as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type>
<ex:function>file:create-temp-file</ex:function>($prefix as <ex:type>xs:string</ex:type>,
                      $suffix as <ex:type>xs:string</ex:type>,
                      $dir as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Creates a temporary file and all non-existing parent directories and
                   returns the full path to the created file.</p>
                <p>The temporary file will not be automatically deleted after query execution.
                   It is guaranteed to not already exist when the function is called.</p>
                <p>If <code>$dir</code> is not given, the directory will be created inside
                   the system-dependent default temporary-file directory.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the specified 
                   does not exist or points to a file.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.delete">
            <head><code>file:delete</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:delete</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:delete</ex:function>($path as <ex:type>xs:string</ex:type>,
            $recursive as <ex:type>xs:boolean</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Deletes a file or a directory from the file system.</p>
                <p>If the optional parameter <code>$recursive</code> is set to <code>true()</code>,
                   sub-directories will be deleted as well.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$path</code> does not
                    exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    non-empty directory.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.list">
            <head><code>file:list</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:list</ex:function>($dir as <ex:type>xs:string</ex:type>) as <ex:type>xs:string*</ex:type>
<ex:function>file:list</ex:function>($dir as <ex:type>xs:string</ex:type>,
          $recursive as <ex:type>xs:boolean</ex:type>) as <ex:type>xs:string*</ex:type>
<ex:function>file:list</ex:function>($dir as <ex:type>xs:string</ex:type>,
          $recursive as <ex:type>xs:boolean</ex:type>,
          $pattern as <ex:type>xs:string</ex:type>) as <ex:type>xs:string*</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Lists all files and directories in a given directory. The order of the items in the
                   resulting sequence is not defined. The "." and ".." items are never returned. The
                   returned paths are relative to the provided directory <code>$dir</code>.</p>
                <p>If the optional parameter <code>$recursive</code> is set to <code>true()</code>, all
                   directories and files will be returned that are found while recursively traversing
                   the given directory.</p>
                <p>The optional <code>$pattern</code> parameter defines a name pattern in the glob
                   syntax. If this is provided, only the paths of the files and directories whose names
                   are matching the pattern will be returned.</p>
                <p>An implementation must support at least the following glob syntax for the pattern: <ul>
                      <li><code>*</code> for matching any number of unknown characters and</li>
                      <li><code>?</code> for matching one unknown character.</li>
                   </ul>
                </p>
                <p>A related function is <loc href="#fn.children">file:children</loc>.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$path</code> does not exist.</item>
                 <item><bibref ref="errND"/> is raised if <code>$dir</code> does not point to a directory.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.move">
            <head><code>file:move</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:move</ex:function>($source as <ex:type>xs:string</ex:type>,
          $target as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Moves a file or a directory given a source and a target path/URI. The following cases
                   may occur if <code>$source</code> points to a file:</p>
                <ol type="a">
                   <li> if <code>$target</code> does not exist, it will be created.</li>
                   <li> if <code>$target</code> is a file, it will be overwritten.</li>
                   <li> if <code>$target</code> is a directory, the file will be created in that
                      directory with the name of the source file. If a file already exists, it will be
                      overwritten.</li>
                </ol>
                <p>The following cases may occur if <code>$source</code> points to a directory:</p>
                <ol type="a">
                   <li> if <code>$target</code> does not exist, it will be created as directory, and all
                      files of the source directory are moved to this directory with their existing
                      local names.</li>
                   <li> if <code>$target</code> is a directory, the source directory with all its files
                     will be moved into the target directory. If the target directory contains a
                     directory with the same name as the source, the error <bibref ref="errID"/> is raised.</li>
                </ol>
                <p>Other cases will raise one of the errors listed below.</p>
                <p>The function returns the empty sequence if the operation is successful. If an error
                   occurs during the operation, no rollback to the original state will be possible </p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if the <code>$source</code> path does not
                    exist.</item>
                 <item><bibref ref="errE"/> is raised if <code>$source</code> points to a
                    directory and <code>$target</code> points to an existing file.</item>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$source</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$target</code> points to a directory,
                    in which a subdirectory exists with the name of the source.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.read-binary">
            <head><code>file:read-binary</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:read-binary</ex:function>($file as <ex:type>xs:string</ex:type>) as <ex:type>xs:base64Binary</ex:type>
<ex:function>file:read-binary</ex:function>($file as <ex:type>xs:string</ex:type>,
                 $offset as <ex:type>xs:integer</ex:type>) as <ex:type>xs:base64Binary</ex:type>
<ex:function>file:read-binary</ex:function>($file as <ex:type>xs:string</ex:type>,
                 $offset as <ex:type>xs:integer</ex:type>,
                 $length as <ex:type>xs:integer</ex:type>) as <ex:type>xs:base64Binary</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the content of a file in its Base64 representation.</p>
                <p>The optional parameters <code>$offset</code> and <code>$length</code> can be
                   used to read chunks of a file.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$file</code> does not
                    exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errOOR"/> is raised if <code>$offset</code> or
                    <code>$length</code> is negative, or if the chosen values would exceed the file bounds.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.read-text">
            <head><code>file:read-text</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:read-text</ex:function>($file as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type>
<ex:function>file:read-text</ex:function>($file as <ex:type>xs:string</ex:type>,
               $encoding as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the content of a file in its string representation.</p>
                <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
                      <code>UTF-8</code>.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$file</code> does not
                    exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or
                    not supported by the implementation.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.read-text-lines">
            <head><code>file:read-text-lines</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:read-text-lines</ex:function>($file as <ex:type>xs:string</ex:type>) as <ex:type>xs:string*</ex:type>
<ex:function>file:read-text-lines</ex:function>($file as <ex:type>xs:string</ex:type>,
                     $encoding as <ex:type>xs:string</ex:type>) as <ex:type>xs:string*</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the contents of a file as a sequence of strings, separated at newline
                   boundaries.</p>
                <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
                      <code>UTF-8</code>.</p>
                <p>The newline handling is the same as for the <code>fn:unparsed-text-lines</code>
                   function in <bibref ref="fo30"/>.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$file</code> does not
                    exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or
                    not supported by the implementation.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.write">
            <head><code>file:write</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:write</ex:function>($file as <ex:type>xs:string</ex:type>,
           $items as <ex:type>item()*</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:write</ex:function>($file as <ex:type>xs:string</ex:type>,
           $items as <ex:type>item()*</ex:type>,
           $params as <ex:type>element(output:serialization-parameters)</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Writes a sequence of items to a file.
                   If <code>$file</code> already exists, it will be overwritten; otherwise, it will be created.</p>
                   <p><code>$params</code> controls the way the <code>$items</code> items are serialized.
                   The semantics of <code>$params</code> is the same as for the
                      <code>fn:serialize</code> function in <bibref ref="fo30"/>. This consists of an
                      <code>output:serialization-parameters</code> element whose format is defined in
                      <bibref ref="ser30"/>. In contrast to fn:serialize, the encoding stage will not be
                   skipped by this function.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.write-binary">
            <head><code>file:write-binary</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:write-binary</ex:function>($file as <ex:type>xs:string</ex:type>,
                  $value as <ex:type>xs:base64Binary</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:write-binary</ex:function>($file as <ex:type>xs:string</ex:type>,
                  $value as <ex:type>xs:base64Binary</ex:type>,
                  $offset as <ex:type>xs:integer</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Writes a Base64 item as binary to a file.
                   If <code>$file</code> already exists, it will be overwritten; otherwise, it will be created.</p>
                <p>If the optional parameter <code>$offset</code> is specified, data will be written
                   to this file position. An existing file may be resized by that operation.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errOOR"/> is raised if <code>$offset</code> is negative,
                    or if it exceeds the current file size.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.write-text">
            <head><code>file:write-text</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:write-text</ex:function>($file as <ex:type>xs:string</ex:type>,
                $value as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:write-text</ex:function>($file as <ex:type>xs:string</ex:type>,
                $value as <ex:type>xs:string</ex:type>,
                $encoding as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Writes a strings to a file. If <code>$file</code> already exists, it will be
                   overwritten.</p>
                <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
                      <code>UTF-8</code>.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or
                    not supported by the implementation.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.write-text-lines">
            <head><code>file:write-text-lines</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:write-text-lines</ex:function>($file as <ex:type>xs:string</ex:type>,
                      $values as <ex:type>xs:string*</ex:type>) as <ex:type>empty-sequence()</ex:type>
<ex:function>file:write-text-lines</ex:function>($file as <ex:type>xs:string</ex:type>,
                      $values as <ex:type>xs:string*</ex:type>,
                      $encoding as <ex:type>xs:string</ex:type>) as <ex:type>empty-sequence()</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Writes a sequence of strings to a file, each followed by the system-dependent newline character.
                   If <code>$file</code> already exists, it will be overwritten; otherwise, it will be created.</p>
                <p>The optional parameter <code>$encoding</code>, if not provided, is considered to be
                      <code>UTF-8</code>.</p>
                <p>The function returns the empty sequence if the operation is successful.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errND"/> is raised if the parent directory of
                       <code>$file</code> does not exist.</item>
                 <item><bibref ref="errID"/> is raised if <code>$file</code> points to a
                    directory.</item>
                 <item><bibref ref="errUE"/> is raised if <code>$encoding</code> is invalid or
                    not supported by the implementation.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>
      </div1>

      <!-- *************************************** Functions on paths ************************* -->
      <div1 id="paths">
         <head>Paths</head>
         <p>None of the functions in this section performs any check regarding the existence of the
            received or returned paths.</p>

         <div2 id="fn.name">
            <head><code>file:name</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:name</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the name of a file or directory.</p>
                <p>An empty string is returned if the path points to the root directory,
                   or if it contains no directory separators.</p>
                <p>This function is ·deterministic· (no path existence check is made).</p>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.parent">
            <head><code>file:parent</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:parent</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:string?</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Transforms the given path into an absolute path, as specified by
                   <loc href="#fn.resolve-path">file:resolve-path</loc>,
                   and returns the parent directory.</p>
                <p>The inverse function is <loc href="#fn.children">file:children</loc>.</p>
                <p>An empty sequence is returned if the path points to a root directory.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.children">
            <head><code>file:children</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:children</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:string*</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Lists all files and directories in a given directory. The order of the items in the
                   resulting sequence is not defined. The "." and ".." items are never returned. The
                   returned paths are relative to the provided directory <code>$dir</code>.</p>
                <p>Returns the paths of all files and directories that are located in the given directory.
                   The order of the items in the resulting sequence is not defined.
                   The "." and ".." items are never returned.</p>
                <p>The inverse function is <loc href="#fn.parent">file:parent</loc>;
                   a related function is <loc href="#fn.list">file:list</loc>.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errNF"/> is raised if <code>$path</code> does not exist.</item>
                 <item><bibref ref="errND"/> is raised if <code>$path</code> does not point to a directory.</item>
                 <item><bibref ref="errIE"/> is raised if any other error occurs.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.path-to-native">
            <head><code>file:path-to-native</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:path-to-native</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Transforms a URI, an absolute path, or relative path to a canonical, system-dependent
                   path representation. A canonical path is both absolute and unique and thus contains
                   no redirections such as references to parent directories or symbolic links.</p>
                <p>If the resulting path points to a directory,
                   it will be suffixed with the system-specific directory separator.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
            <gitem>
              <label>Error Conditions</label>
              <def>
                <ulist>
                 <item><bibref ref="errIE"/> is raised if an error occurs while trying to obtain
                    the native path.</item>
                </ulist>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.path-to-uri">
            <head><code>file:path-to-uri</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:path-to-uri</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:anyURI</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Transforms a file system path into a URI with the <code>file://</code> scheme. If the
                   path is relative, it is first resolved against the current working directory.</p>
                <p>This function is ·deterministic· (no path existence check is made).</p>
              </def>
            </gitem>
         </div2>

         <div2 id="fn.resolve-path">
            <head><code>file:resolve-path</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:resolve-path</ex:function>($path as <ex:type>xs:string</ex:type>) as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Transforms a relative path into an absolute operating system path by resolving it
                   against the current working directory.</p>
                <p>If the resulting path points to a directory,
                   it will be suffixed with the system-specific directory separator.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>
      </div1>

      <!-- ************************************************************************************ -->
      <div1 id="sys-props">
         <head>System Properties</head>

         <div2 id="pr.dir-separator">
            <head><code>file:dir-separator</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:dir-separator</ex:function>() as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the value of the operating system-specific directory separator, which usually
                   is <code>/</code> on UNIX-based systems and <code>\</code> on Windows systems.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.line-separator">
            <head><code>file:line-separator</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg>
<ex:function>file:line-separator</ex:function>() as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the value of the operating system-specific line separator, which usually is
                      <code>&amp;#10;</code> on UNIX-based systems, <code>&amp;#13;&amp;#10;</code> on
                   Windows systems and <code>&amp;#13;</code> on Mac systems.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.path-separator">
            <head><code>file:path-separator</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:path-separator</ex:function>() as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the value of the operating system-specific path separator, which usually is
                      <code>:</code> on UNIX-based systems and <code>;</code> on Windows systems.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.temp-dir">
            <head><code>file:temp-dir</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:temp-dir</ex:function>() as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the path to the default temporary-file directory of an operating system.</p>
                <p>This function is ·nondeterministic·.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.base-dir">
            <head><code>file:base-dir</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:base-dir</ex:function>() as <ex:type>xs:string?</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the parent directory of the static base URI.
                If the Base URI property is undefined, the empty sequence is returned. -
                If a static base URI exists, and if points to a local file path,
                this function returns the same result as the expression
                <code>file:parent(static-base-uri())</code>.</p>
              </def>
            </gitem>
         </div2>

         <div2 id="pr.current-dir">
            <head><code>file:current-dir</code></head>
            <gitem>
              <label>Signature</label>
              <def><p><eg><ex:function>file:current-dir</ex:function>() as <ex:type>xs:string</ex:type></eg></p></def>
            </gitem>
            <gitem>
              <label>Rules</label>
              <def>
                <p>Returns the current working directory. -
                This function returns the same result as the function call
                <code>file:resolve-path('.')</code>.</p>
              </def>
            </gitem>
         </div2>
      </div1>
   </body>

   <back>
      <div1 id="refs">
         <head>References</head>
         <blist>
            <bibl id="ser30" key="XSLT and XQuery Serialization 3.0">
               <loc href="http://www.w3.org/TR/xslt-xquery-serialization-30/">XSLT and XQuery
                  Serialization 3.0</loc>. Henry Zongaro. W3C Working Draft 14 December 2010.</bibl>
            <bibl id="fo30" key="XQuery and XPath Functions and Operators 3.0">
               <loc href="http://www.w3.org/TR/xpath-functions-30/">XPath and XQuery Functions and
                  Operators 3.0</loc>. Michael Kay. W3C Working Draft 14 December 2010.</bibl>
         </blist>
      </div1>
      <div1 id="errors">
         <head>Summary of Error Conditions</head>
         <blist>
            <bibl id="errNF" key="file:not-found">The specified path does not exist.</bibl>
            <bibl id="errIP" key="file:invalid-path">The specified path is invalid.</bibl>
            <bibl id="errE"  key="file:exists">The specified path already exists.</bibl>
            <bibl id="errND" key="file:no-dir">The specified path does not point to a directory.</bibl>
            <bibl id="errID" key="file:is-dir">The specified path points to a directory.</bibl>
            <bibl id="errUE" key="file:unknown-encoding">The specified encoding is not supported.</bibl>
            <bibl id="errOOR" key="file:out-of-range">The specified offset or length is negative,
               or the chosen values would exceed the file bounds.</bibl>
            <bibl id="errIE" key="file:io-error">A generic file system error occurred.</bibl>
         </blist>
      </div1>
   </back>
</spec>
