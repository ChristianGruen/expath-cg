<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>MongoDB Module</title><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/base.css" /><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

      code.function { font-weight: bold; }
      code.type { font-style: italic; }
      /* h1, h2, h3 { color: #84001C; background: white } */
      /* a, :link, :visited, a:active { color: #84005C; background: white } */
      body {
        background-image: url(http://expath.org/images/logo-candidate.png);
      }
   </style></head><body><p><a href="http://w3.org/"><img src="http://w3.org/Icons/w3c_home" alt="W3C" height="48" width="72" /></a></p><div class="head">
<h1><a name="title" id="title"></a>MongoDB Module</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>EXPath Working Draft 5 March 2015</h2><dl><dt>This version:</dt><dd>
      <a href="http://expath.org/spec/mongodb/20150315">http://expath.org/spec/mongodb/20150315</a><br />
    </dd><dt>Latest version:</dt><dd>
      <a href="http://expath.org/spec/mongodb">http://expath.org/spec/mongodb</a><br />
    </dd><dt>Editors:</dt><dd>Christian Grün, BaseX GmbH</dd><dd>Dannes Wessels, eXist Solutions GmbH</dd></dl><p>This document is also available in these non-normative formats: <a href="http://expath.org/spec/mongodb/20150315.xml">XML</a> and <a href="http://expath.org/spec/mongodb/20150315/diff">Revision markup</a>.</p><p class="copyright">Copyright © 2015 Christian Grün and Dannes Wessels, published by the <a href="http://w3.org/community/expath/">EXPath Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
           License Agreement (CLA)</a>. A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is
        available.</p><p class="copyright">This specification was published by the <a href="http://www.w3.org/community/expath/">EXPath Community Group</a>. It is not a W3C Standard nor is it on the W3C
        Standards Track. Please note that under the <a href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
           License Agreement (CLA)</a> there is a limited opt-out and other conditions apply.s
        Learn more about <a href="http://www.w3.org/community/">W3C Community and Business
           Groups</a>.</p></div><hr /><div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2><p>This module provides an API for accessing the document database MongoDB.
        It defines functions to connect to the DBMS, retrieve documents from databases
        and collections, update resources, perform map-reduce queries, and execute
        server-side JavaScript functions and database commsands.</p><p>The module has been designed to be compatible with XQuery 3.1 and XPath 3.1, and
        later versions. It has been inspired by existing <a href="#drivers">[MongoDB Drivers]</a> and the
        <a href="#meta-driver">[MongoDB Meta Driver]</a> recommendations. Its initial version was based on
        <a href="#mongrel">[Mongrel]</a>.
      </p></div><div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2><p class="toc">1 <a href="#status">Status of this document</a><br />
2 <a href="#intro">Introduction</a><br />
    2.1 <a href="#namespaces">Namespace conventions</a><br />
    2.2 <a href="#d3e124">Error management</a><br />
    2.3 <a href="#exec">JSON Data</a><br />
    2.4 <a href="#exec">Query Execution</a><br />
    2.5 <a href="#testing">Test suite</a><br />
3 <a href="#fns.client">Client Operations</a><br />
    3.1 <a href="#fn.connect">mongodb:connect</a><br />
    3.2 <a href="#fn.list-databases">mongodb:list-databases</a><br />
    3.3 <a href="#fn.close">mongodb:close</a><br />
4 <a href="#fns.databases">Database Operations</a><br />
    4.1 <a href="#fn.list-collections">mongodb:list-collections</a><br />
    4.2 <a href="#fn.command">mongodb:command</a><br />
    4.3 <a href="#fn.eval">mongodb:eval</a><br />
    4.4 <a href="#fn.drop-database">mongodb:drop-database</a><br />
5 <a href="#fns.collections-read">Collections: Read Operations</a><br />
    5.1 <a href="#fn.find">mongodb:find</a><br />
    5.2 <a href="#fn.find-one">mongodb:find-one</a><br />
    5.3 <a href="#fn.count">mongodb:count</a><br />
    5.4 <a href="#fn.aggregate">mongodb:aggregate</a><br />
    5.5 <a href="#fn.group">mongodb:group</a><br />
    5.6 <a href="#fn.map-reduce">mongodb:map-reduce</a><br />
6 <a href="#fns.collections-write">Collections: Update Operations</a><br />
    6.1 <a href="#fn.find-and-modify">mongodb:find-and-modify</a><br />
    6.2 <a href="#fn.find-and-remove">mongodb:find-and-remove</a><br />
    6.3 <a href="#fn.insert">mongodb:insert</a><br />
    6.4 <a href="#fn.save">mongodb:save</a><br />
    6.5 <a href="#fn.update">mongodb:update</a><br />
    6.6 <a href="#fn.remove">mongodb:remove</a><br />
    6.7 <a href="#fn.drop-collection">mongodb:drop-collection</a><br />
</p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3><p class="toc">A <a href="#refs">References</a><br />
B <a href="#errors">Summary of Error Conditions</a><br />
</p></div><hr /><div class="body"><div class="div1">
<h2><a name="status" id="status"></a>1 Status of this document</h2><p>This document is in an interim draft stage. Comments are welcomed at <a href="mailto:public-expath@w3.org">public-expath@w3.org</a> mailing list (<a href="http://lists.w3.org/Archives/Public/public-expath/">archive</a>).</p></div><div class="div1">
<h2><a name="intro" id="intro"></a>2 Introduction</h2><div class="div2">
<h3><a name="namespaces" id="namespaces"></a>2.1 Namespace conventions</h3><p>The module defined by this document defines functions and errors in the
          namespace <code>http://expath.org/ns/mongodb</code>. In this document, the
          <code>mongodb</code> prefix is bound to this namespace URI. Error codes are
          defined in the same namespace and are displayed with the same prefix.
        </p><p>The <code>err</code> prefix denotes the namespace for XPath and XQuery errors,
          <code>http://www.w3.org/2005/xqt-errors</code>, as defined in the
          <a href="#xquery31">[XQuery 3.1]</a> specification.</p></div><div class="div2">
<h3><a name="d3e124" id="d3e124"></a>2.2 Error management</h3><p>
          Error conditions are identified by a code (a <code>QName</code>). When such
          an error condition is reached in the evaluation of an expression, a dynamic
          error is thrown, with the corresponding error code (as if the standard XPath
          function <code>error()</code> had been called).
        </p><p>The following errors apply to most functions of this specification:
          <ul><li><p><a href="#error.id">[mongodb:id]</a> is raised if no database connection exists
              for a given client id.</p></li><li><p><a href="#error.json">[mongodb:json]</a> is raised if a supplied XQuery map
              cannot be converted to a valid JSON object.</p></li><li><p><a href="#error.io">[mongodb:io]</a> is raised if an unexpected error (connection
              failure, timeout) occurs while interacting with the database.</p></li><li><p><a href="#error.name">[mongodb:name]</a> is raised if an invalid database name is
              specified. Database names must have 1-63 characters, and they must not
              contain any of the following twelve characters:
              <code>/\. "$*&lt;&gt;:|?</code></p></li><li><p><a href="#error.name">[mongodb:name]</a> is also raised if an invalid collection
              name is specified. Collection names must have 1-117 characters, and they
              must not contain the dollar sign ($).</p></li></ul>
          Remaining error codes are specified along with the functions.
          For a list of all errors, see the <a href="#errors">Summary of Error
          Conditions</a> section of this document.
        </p></div><div class="div2">
<h3><a name="exec" id="exec"></a>2.3 JSON Data</h3><p>Since Version 3.1, maps and arrays are available in XQuery and XPath.
          This specification makes heavy use of the feature: all JSON objects and arrays
          are represented in the equivalent XQuery data types.
        </p><p>If JSON strings are preferred as input and output, the functions 
          <code>fn:parse-json</code> and <code>fn:serialize</code> of the
          <a href="#xquery31fo">[XPath and XQuery Functions and Operators 3.1]</a> specification can be used for conversion.
          The following query parses a JSON string and returns an XQuery map. The "liberal"
          option accepts deviation from <a href="#rfc7159">[RFC 7159]</a>, such as the omission of
          quotes on keys:</p><div class="exampleInner"><pre>fn:parse-json('{ info: "Hello Universe" }', map { "liberal": true() })</pre></div><p>The next example shows how XQuery maps can be serialized as JSON:</p><div class="exampleInner"><pre>
fn:serialize(map { 'info': 'Hello Universe' },
  &lt;output:serialization-parameters xmlns:output='http://www.w3.org/2010/xslt-xquery-serialization'&gt;
    &lt;output:method value='json'/&gt;
  &lt;/output:serialization-parameters&gt;
)</pre></div></div><div class="div2">
<h3><a name="exec" id="exec"></a>2.4 Query Execution</h3><p>All functions in this module are ·nondeterministic·. Non-deterministic
          functions may return different results when executed more than once.
          This is illustrated by two examples:
        </p><ul><li><p>The <a href="#fn.find">mongodb:find</a> may return different
            results when called more than once, as the contents of the MongoDB database
            instance may have changed between the first and second call.</p></li><li><p>Calling <a href="#fn.insert">mongodb:insert</a> may be successful
            for the first time, but it may fail when called twice, because the document to
            be added will already exist.</p></li></ul><p>A query processor must ensure that non-deterministic functions are not
          relocated or rewritten in the query, and that its results are not cached at
          runtime.</p></div><div class="div2">
<h3><a name="testing" id="testing"></a>2.5 Test suite</h3><p>A <a href="#test-suite">[MongoDB Test Suite]</a> is provided to ensure compatibility across
          different implementations of the specification. It is based on the QT3 format;
          see <a href="#qt3">[XML Query Test Suite]</a> for more details.
        </p></div></div><div class="div1">
<h2><a name="fns.client" id="fns.client"></a>3 Client Operations</h2><div class="div2">
<h3><a name="fn.connect" id="fn.connect"></a>3.1 <code>mongodb:connect</code></h3><dl><dt class="label">Signatures</dt><dd><div class="exampleInner"><pre><code class="function">mongodb:connect</code>($uri as <code class="type">xs:string</code>) as <code class="type">xs:string</code></pre></div></dd><dt class="label">Rules</dt><dd><p>Establishes a connection to MongoDB and returns a client id as string
                that identifies the opened connection.</p><p>The <code>$uri</code> string follows the MongoDB URI format. It must
                at least contain one host name, and it may be prefixed with the
                <code>mongodb</code> scheme and suffixed with a port number.
                Multiple hosts, e.g. for a replica set, are separated with commas.</p></dd><dt class="label">Implementation Notes</dt><dd><p>The format of the returned client id string is implementation-defined,
                but all returned ids must be unique during the evaluation of a query.</p></dd><dt class="label">Error Conditions</dt><dd><ul><li><p><a href="#error.connect">[mongodb:connect]</a> is raised if the connection could not be
                    established, possibly due to a wrong URL or a connection failure.</p></li></ul></dd><dt class="label">Examples</dt><dd><p>The following expression creates three connections to local MongoDB
                instances, using the default port, and returns the client ids as result:
                <div class="exampleInner"><pre>
mongodb:connect("localhost"),
mongodb:connect("localhost:27017"),
mongodb:connect("mongodb://localhost:27017")</pre></div>
              </p><p>The following function call connects to a replica set with three members,
                and distributes reads to the secondary:
                <div class="exampleInner"><pre>mongodb:connect("localhost,localhost:27018/?readPreference=secondary")</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.list-databases" id="fn.list-databases"></a>3.2 <code>mongodb:list-databases</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:list-databases</code>($client-id as <code class="type">xs:string</code>) as <code class="type">xs:string*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Returns the names of all databases on the connected server.</p><p>The connection is identified by the supplied <code>$client-id</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query lists all databases on localhost:</p><p>
                <div class="exampleInner"><pre>mongodb:list-databases(mongodb:connect("localhost"))</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.close" id="fn.close"></a>3.3 <code>mongodb:close</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:close</code>($client-id as <code class="type">xs:string</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Closes an open database connection. The connection to be closed is
                identified by the supplied <code>$client-id</code>. When a database connection
                is closed, the associated id is discarded and invalidated. As a consequence,
                each database can be closed once.</p></dd><dt class="label">Implementation Notes</dt><dd><p>A connection must be kept open as long as it has not explicitly been 
                closed by the user, and as long as the query has not been fully evaluated.
                After query evaluation, an implementation must ensure that
                all remaining connections are automatically closed.</p></dd><dt class="label">Examples</dt><dd><p>The following expression closes a connection that has just been opened:</p><p>
                <div class="exampleInner"><pre>mongodb:close(mongodb:connect("localhost"))</pre></div>
              </p></dd></dl></div></div><div class="div1">
<h2><a name="fns.databases" id="fns.databases"></a>4 Database Operations</h2><p>The module provides no function for creating new databases, because non-existing
        databases will automatically be created by MongoDB with the first write
        operation.</p><div class="div2">
<h3><a name="fn.list-collections" id="fn.list-collections"></a>4.1 <code>mongodb:list-collections</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:list-collections</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>) as <code class="type">xs:string*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Returns the names of all collections contained in a databases.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database is supplied via <code>$database</code>.</p></dd></dl></div><div class="div2">
<h3><a name="fn.command" id="fn.command"></a>4.2 <code>mongodb:command</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:command</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>,
    $command as <code class="type">map(*)</code>) as <code class="type">map(*)</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Executes a <a href="#mongodb-command">[MongoDB Command]</a>, supplied via
                <code>$command</code>, and returns the result as a map.
              </p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database is supplied via <code>$database</code>.</p></dd><dt class="label">Implementation Notes</dt><dd><p>
                The object returned by MongoDB contains the field <code>ok</code>, which
                must be parsed by the implementation to decide if command execution was
                successful (indicated by the integer value <code>1</code>) or not
                (<code>0</code>). The field must be removed from the object before the
                result is returned as map. If execution failed, the field
                <code>errmsg</code> can be parsed to return a proper error message.
              </p></dd><dt class="label">Error Conditions</dt><dd><ul><li><p><a href="#error.exec">[mongodb:exec]</a> is raised if command execution failed.</p></li></ul></dd><dt class="label">Examples</dt><dd><p>The following query clones a database from a remote MongoDB instance to
                the current host. The result will either be a map, which contains the
                result of the command execution, or an error:
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return try {
  mongodb:command($client-id, map { "clone", 1 })
} catch mongodb:exec {
  "Command execution failed: " || $err:description,
}</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.eval" id="fn.eval"></a>4.3 <code>mongodb:eval</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:eval</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>,
    $code as <code class="type">xs:string</code>) as <code class="type">item()*</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:eval</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>,
    $code as <code class="type">xs:string</code>, $args as <code class="type">item()*</code>) as <code class="type">item()*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Runs server-server JavaScript script code, supplied via <code>$code</code>.
                Function arguments can be supplied via <code>$args</code>. Arguments can
                be booleans, strings, numbers, arrays or maps. An error will be raised if
                any other type is supplied.
                Items of type xs:untypedAtomic are converted to strings.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database is supplied via <code>$database</code>.</p></dd><dt class="label">Implementation Notes</dt><dd><p>Due to the different type systems of XQuery and JavaScript, it is not
                possible to losslessly convert all values to one language and back.
                To ensure compatibility, an implementation must obey the following
                conversion rules:</p><p>
                Conversion of XQuery arguments to JavaScript:
                <ul><li><p>A value of type xs:boolean is converted to a boolean.</p></li><li><p>A value of type xs:string and xs:untypedAtomic are converted to a
                      string.</p></li><li><p>A value of type xs:numeric is converted to a number (i.e. a
                      double-precision floating-point format value).</p></li><li><p>A value of type map(*) is converted to an object. Its entries must
                      be converted recursively according to the given rules.</p></li><li><p>A value of type array(*) is converted to an array. Its members must
                      be converted recursively according to the given rules.</p></li><li><p>The error <a href="#error.type">[mongodb:type]</a> is raised for any other type.</p></li></ul>
              </p><p>
                Conversion of JavaScript results to XQuery:
                <ul><li><p>A boolean is converted to xs:boolean.</p></li><li><p>A string is converted to xs:string.</p></li><li><p>A number is converted to xs:double.</p></li><li><p>An object is converted to map(*). Its entries must be converted
                      recursively according to the given rules.</p></li><li><p>An array is converted to array(*). Its members must be converted
                      recursively according to the given rules.</p></li><li><p>The error <a href="#error.type">[mongodb:type]</a> is raised for any other type.</p></li></ul>
              </p></dd><dt class="label">Error Conditions</dt><dd><ul><li><p><a href="#error.type">[mongodb:type]</a> is raised if an XQuery argument cannot be
                    converted to Javascript, or if a Javascript result cannot be converted
                    to XQuery.</p></li><li><p><a href="#error.exec">[mongodb:exec]</a> is raised if JavaScript execution
                    failed.</p></li></ul></dd><dt class="label">Examples</dt><dd><p>The following query returns the result of an arithmetic expression:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:eval($client-id, "db",
  'function ( x, y ) { return x + y; }',
  (2, 5)
)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.drop-database" id="fn.drop-database"></a>4.4 <code>mongodb:drop-database</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:drop-database</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Drops a database. No operation will be performed if the database does
                not exist.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database is supplied via <code>$database</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query drops five databases (provided they exist):</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
for $no in 1 to 5
return mongodb:drop-database($client-id, "database-" || $no)</pre></div>
              </p></dd></dl></div></div><div class="div1">
<h2><a name="fns.collections-read" id="fns.collections-read"></a>5 Collections: Read Operations</h2><div class="div2">
<h3><a name="fn.find" id="fn.find"></a>5.1 <code>mongodb:find</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:find</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>) as <code class="type">map(*)*</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:find</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>) as <code class="type">map(*)*</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:find</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>, $options as <code class="type">map(*)</code>) as <code class="type">map(*)*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Returns documents of a collection. If a query is supplied via the
                <code>$query</code> argument, the documents are filtered by that query.
                The <code>$options</code> argument can have the following entries:
                <ul><li><p><code>"fields": map(*)</code>: Restricts the returned fields.
                      The field <code>_id</code> will always be returned.</p></li><li><p><code>"sort": map(*)</code>: Sorts the returned documents.</p></li><li><p><code>"limit": xs:integer</code>: Limits the number of returned
                      documents by the specified integer.</p></li><li><p><code>"skip": xs:integer</code>: Skips the number of specified
                      documents.</p></li></ul>
              </p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following expression queries an addressbook and selects all persons
                living in Tokyo. It sorts results by the names and returns the first
                50 documents:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:find($client-id, 'db', 'addressbook',
  map { "city": "Tokyo" },
  map {
    "sort": map { "name": 1 },
    "limit": 50
  }
)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.find-one" id="fn.find-one"></a>5.2 <code>mongodb:find-one</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:find-one</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>) as <code class="type">map(*)?</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:find-one</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>) as <code class="type">map(*)?</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:find-one</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>, $options as <code class="type">map(*)</code>) as <code class="type">map(*)?</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Returns the first document of a database that optionally matches a
                supplied <code>$query</code>.
                The <code>$options</code> argument can have have the following entries:
                <ul><li><p><code>"fields": map(*)</code>: Restricts the returned fields.
                      The field <code>_id</code> will always be returned.
                    </p></li><li><p><code>"sort": map(*)</code>: Sorts the documents before returning
                      the first result.</p></li></ul>
              </p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query returns the first document that matches the specified query:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:find-one($client-id, 'db', 'addressbook', map { "name": "John Taylor" })</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.count" id="fn.count"></a>5.3 <code>mongodb:count</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:count</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>) as <code class="type">xs:integer</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:count</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>) as <code class="type">xs:integer</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Counts documents in a collection. If a query is supplied via the
                <code>$query</code> argument, the documents are filtered by that query.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following expression counts the number of documents in the
                "addressbook" collection:</p><p>
                <div class="exampleInner"><pre>mongodb:count(mongodb:connect("localhost"), 'db', 'addressbook')</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.aggregate" id="fn.aggregate"></a>5.4 <code>mongodb:aggregate</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:aggregate</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $pipeline as <code class="type">map(*)*</code>) as <code class="type">map(*)*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Calculates aggregate values for the documents in a collection and returns
                the results. The operations to be performed are supplied via
                the <code>$pipeline</code> argument.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query selects all documents with "Tokyo" as city and
                returns their names:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:aggregate($client-id, "db","addressbook",
  (map { "$match"  : map { "city": "Tokyo" } },
   map { "$project": map { "name": 1 } })
)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.group" id="fn.group"></a>5.5 <code>mongodb:group</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:group</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $fields as <code class="type">map(*)</code>, $reduce as <code class="type">xs:string</code>, $initial as <code class="type">map(*)</code>) as <code class="type">map(*)*</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:group</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $fields as <code class="type">map(*)</code>, $reduce as <code class="type">xs:string</code>, $initial as <code class="type">map(*)</code>,
    $options as <code class="type">map(*)</code>) as <code class="type">map(*)*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Groups documents in a collection by the supplied <code>$fields</code>,
                aggregates the documents via the <code>$reduce</code> function, and
                returns the results. <code>$initial</code> provides an initial result
                document, which will be modified by the reduce function.
                The <code>$options</code> argument can have the following entries:
                <ul><li><p><code>"cond": map(*)</code>: Filters the documents before being
                      processed.</p></li><li><p><code>"finalize": xs:string</code>: Follows the reduce function
                      and modifies the output.</p></li></ul>
              </p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following groups documents with age &gt; 60 by the city field
                and returns the summed up orders field:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:group($client-id, "db", "addressbook",
  map { "city": 1 },
  "function (curr, result) { result.orders += curr.orders; }",
  map { "orders": 0 },
  map {
    "cond": map { "age": map { "$gt": 60 } }
  }
)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.map-reduce" id="fn.map-reduce"></a>5.6 <code>mongodb:map-reduce</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:map-reduce</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $map as <code class="type">xs:string</code>, $reduce as <code class="type">xs:string</code>) as <code class="type">map(*)*</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:map-reduce</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $map as <code class="type">xs:string</code>, $reduce as <code class="type">xs:string</code>, $options as <code class="type">map(*)</code>) as <code class="type">map(*)*</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Runs a map-reduce aggregation operation over the documents of a
                collection. The map and reduce functions are supplied via the
                <code>$map</code> and <code>$reduce</code> arguments.
                The <code>$options</code> argument can have the following entries:
                <ul><li><p><code>"query": map(*)</code>: Filters the documents before being
                      processed.</p></li><li><p><code>"output": xs:string</code>: Specifies the output target
                      of the result.</p></li><li><p><code>"type": xs:string</code>: Specifies the output type. Allowed
                      values are <code>INLINE</code> (default), <code>REPLACE</code>,
                      <code>MERGE</code> and <code>REDUCE</code>.</p></li><li><p><code>"finalize": xs:string</code>: Follows the reduce function
                      and modifies the output.</p></li><li><p><code>"sort": map(*)</code>: Sorts the returned documents.</p></li><li><p><code>"limit": xs:integer</code>: Limits the number of returned
                      documents by the specified integer.</p></li></ul>
              </p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query sums up the numbber of orders from all documents
                of the "addressbook" collection:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:map-reduce($client-id, "db", "addressbook",
  'function () { emit(this._id, this.orders) };',
  'function (id, ordersArray) { return Array.sum(ordersArray); };'
)</pre></div>
              </p></dd></dl></div></div><div class="div1">
<h2><a name="fns.collections-write" id="fns.collections-write"></a>6 Collections: Update Operations</h2><div class="div2">
<h3><a name="fn.find-and-modify" id="fn.find-and-modify"></a>6.1 <code>mongodb:find-and-modify</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:find-and-modify</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>, $update as <code class="type">map(*)</code>) as <code class="type">map(*)?</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:find-and-modify</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>, $update as <code class="type">map(*)</code>, $options as <code class="type">map(*)</code>) as <code class="type">map(*)?</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Finds a document that has been selected via the <code>$query</code>
                argument, modifies it according to the <code>$update</code> argument, and
                returns the document as it was before the modifications. An empty sequence
                is returned if no document was found.
                The <code>$options</code> argument can have the following entries:
              </p><ul><li><p><code>"fields": map(*)</code>: Restricts the returned fields.
                    The field <code>_id</code> will always be returned.</p></li><li><p><code>"sort": map(*)</code>: Sorts the documents before choosing the
                    first one as candidate for modification.</p></li><li><p><code>"new": xs:boolean</code>: Returns the modified document
                    rather than the original.</p></li></ul><p>
                The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query modifies a document with the specified id:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:find-and-modify($client-id, 'db', 'addressbook',
  map { "_id": 123 },
  map { "name": "Naomi Matsuo", "city": "Tokyo", "country": "Japan" }
)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.find-and-remove" id="fn.find-and-remove"></a>6.2 <code>mongodb:find-and-remove</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:find-and-remove</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>) as <code class="type">map(*)?</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Finds a document that has been selected via the <code>$query</code>
                argument and returns it after removing it from the database. An empty
                sequence is returned if no document was found.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query removes a document with the specified id:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:find-and-remove($client-id, 'db', 'addressbook', map { "_id": 123 })</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.insert" id="fn.insert"></a>6.3 <code>mongodb:insert</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:insert</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $documents as <code class="type">map(*)*</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Inserts documents into a collection. If the collection does not exists on
                the server, it will be created. If the new document does not contain an
                <code>_id</code> field, it will be added.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Error Conditions</dt><dd><ul><li><p><a href="#error.write">[mongodb:write]</a> is raised if a document cannot be
                    inserted. This can e.g. happen if document with an identical id
                    already exists.</p></li></ul></dd><dt class="label">Examples</dt><dd><p>The following expression inserts two new documents into a collection:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
let $docs := (map { 'name': 'John Daniels' }, map { 'name': 'Jack Walker' })
return mongodb:insert($client-id, 'db', 'addressbook', $docs)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.save" id="fn.save"></a>6.4 <code>mongodb:save</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:save</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $document as <code class="type">map(*)</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Updates an existing document in a collection or inserts a new document.
                If the supplied document has no <code>_id</code> field, or if the id does
                not exist in the collection, the document will be inserted. Otherwise,
                the existing document will be replaced.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following expression updates or inserts a single document:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
let $doc := map { '_id': 123, name': 'Hans Schmid' }
return mongodb:save($client-id, 'db', 'addressbook', $doc)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.update" id="fn.update"></a>6.5 <code>mongodb:update</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:update</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>, $update as <code class="type">map(*)</code>) as <code class="type">empty-sequence()</code></pre></div></p><p><div class="exampleInner"><pre><code class="function">mongodb:update</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>, $update as <code class="type">map(*)</code>, $options as <code class="type">map(*)</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Finds one or more document that have been selected via the
                <code>$query</code> argument and modifies them according to the
                <code>$update</code> argument.
                The <code>$options</code> argument can have have the following entries:
              </p><ul><li><p><code>"upsert": xs:boolean</code>: Inserts a new document if no
                    document matches the query criteria.</p></li><li><p><code>"multi": xs:boolean</code>: Updates all documents in the
                    collection that match the update query. Otherwise, updates only
                    one document.</p></li></ul><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Error Conditions</dt><dd><ul><li><p><a href="#error.write">[mongodb:write]</a> is raised if a document cannot be
                    inserted. This can e.g. happen if a user tries to change the id of the
                    document.</p></li></ul></dd><dt class="label">Examples</dt><dd><p>The following update applies to all documents in the addressed collection.
                It replaces the value of the <code>info</code> field with <code>null</code>,
                or adds a new name/value pair if the field does not exist:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
return mongodb:update($client-id, 'db', 'addressbook',
  map { },
  map { '$set': map { 'info': () } },
  map { 'upsert': true(), 'multi': true() }
)</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.remove" id="fn.remove"></a>6.6 <code>mongodb:remove</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:remove</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>,
    $query as <code class="type">map(*)</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Removes documents from a collection that are selected by the
                <code>$query</code> argument.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following expression removes all documents from a collection:</p><p>
                <div class="exampleInner"><pre>mongodb:remove(mongodb:connect("localhost"), 'db', 'addressbook', map { })</pre></div>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.drop-collection" id="fn.drop-collection"></a>6.7 <code>mongodb:drop-collection</code></h3><dl><dt class="label">Signatures</dt><dd><p><div class="exampleInner"><pre><code class="function">mongodb:drop-collection</code>($client-id as <code class="type">xs:string</code>, $database as <code class="type">xs:string</code>, $collection as <code class="type">xs:string</code>) as <code class="type">empty-sequence()</code></pre></div></p></dd><dt class="label">Rules</dt><dd><p>Drops a collection. No operation will be performed if the collection does
                not exist.</p><p>The connection is identified by the supplied <code>$client-id</code>,
                and the name of the database and collection are supplied via
                <code>$database</code> and <code>$collection</code>.</p></dd><dt class="label">Examples</dt><dd><p>The following query drops five collections in a database:</p><p>
                <div class="exampleInner"><pre>
let $id := mongodb:connect("localhost")
for $no in 1 to 5
return mongodb:drop-collection($client-id, "database", "collection-" || $no)</pre></div>
              </p></dd></dl></div></div></div><div class="back"><div class="div1">
<h2><a name="refs" id="refs"></a>A References</h2><dl><dt class="label"><a name="mongodb-command" id="mongodb-command"></a>MongoDB Command</dt><dd>MongoDB Database Commands. URL:
            <a href="http://docs.mongodb.org/manual/reference/command/">http://docs.mongodb.org/manual/reference/command/</a>
          </dd><dt class="label"><a name="drivers" id="drivers"></a>MongoDB Drivers</dt><dd>MongoDB Drivers. URL:
            <a href="http://docs.mongodb.org/ecosystem/drivers">http://docs.mongodb.org/ecosystem/drivers</a>
          </dd><dt class="label"><a name="meta-driver" id="meta-driver"></a>MongoDB Meta Driver</dt><dd>MongoDB Meta Driver. URL:
            <a href="http://docs.mongodb.org/meta-driver/latest">http://docs.mongodb.org/meta-driver/latest</a>
          </dd><dt class="label"><a name="test-suite" id="test-suite"></a>MongoDB Test Suite</dt><dd>MongoDB Test Suite. URL:
            <a href="http://github.com/expath/expath-cg/tree/master/tests/qt3/mongodb">http://github.com/expath/expath-cg</a>,
            directory: <em>tests/qt3/mongodb/</em>.
          </dd><dt class="label"><a name="mongrel" id="mongrel"></a>Mongrel</dt><dd>Mongrel, the eXist-db MongoDB extension. URL:
            <a href="https://github.com/dizzzz/Mongrel">https://github.com/dizzzz/Mongrel</a>
          </dd><dt class="label"><a name="qt3" id="qt3"></a>XML Query Test Suite</dt><dd>XML Query Test Suite. URL:
            <a href="http://dev.w3.org/2011/QT3-test-suite">http://dev.w3.org/2011/QT3-test-suite</a>
          </dd><dt class="label"><a name="xquery31" id="xquery31"></a>XQuery 3.1</dt><dd>XQuery 3.1: An XML Query Language.
            Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors.
            World Wide Web Consortium. URL:
            <a href="http://www.w3.org/TR/xquery-31">http://www.w3.org/TR/xquery-31</a>
          </dd><dt class="label"><a name="xquery31fo" id="xquery31fo"></a>XPath and XQuery Functions and Operators 3.1</dt><dd>
            XPath and XQuery Functions and Operators 3.1. Michael Kay, Editor.
            World Wide Web Consortium. URL:
            <a href="http://www.w3.org/TR/xpath-functions-31">http://www.w3.org/TR/xpath-functions-31</a>
          </dd><dt class="label"><a name="rfc7159" id="rfc7159"></a>RFC 7159</dt><dd>
            RFC 7159 – The JavaScript Object Notation (JSON) Data Interchange Format.
            Internet Engineering Task Force (IETF). URL:
            <a href="http://www.rfc-editor.org/rfc/rfc7159.txt">http://www.rfc-editor.org/rfc/rfc7159.txt</a>
          </dd></dl></div><div class="div1">
<h2><a name="errors" id="errors"></a>B Summary of Error Conditions</h2><dl><dt class="label"><a name="error.connect" id="error.connect"></a>mongodb:connect</dt><dd>
            A new database connection could not be established.
          </dd><dt class="label"><a name="error.exec" id="error.exec"></a>mongodb:exec</dt><dd>
            Command execution failed.
          </dd><dt class="label"><a name="error.id" id="error.id"></a>mongodb:id</dt><dd>
            No open database connection exists for the supplied client id.
          </dd><dt class="label"><a name="error.io" id="error.io"></a>mongodb:io</dt><dd>
            An unexpected error occurred while interacting with the database.
          </dd><dt class="label"><a name="error.json" id="error.json"></a>mongodb:json</dt><dd>
            A supplied XQuery map could be converted to a JSON object.
          </dd><dt class="label"><a name="error.name" id="error.name"></a>mongodb:name</dt><dd>
            The name of a database or collection is invalid.
          </dd><dt class="label"><a name="error.type" id="error.type"></a>mongodb:type</dt><dd>
            An XQuery argument cannot be converted to Javascript, or a Javascript result
            cannot be converted to XQuery.
          </dd><dt class="label"><a name="error.write" id="error.write"></a>mongodb:write</dt><dd>
            A write operation failed.
          </dd></dl></div></div><script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
         </script><script type="text/javascript">
            try {
               var pageTracker = _gat._getTracker("UA-5463082-2");
               pageTracker._trackPageview();
            } catch(err) {}
         </script></body></html>