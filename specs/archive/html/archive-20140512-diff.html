<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Archive Module -- Review Version</title><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/base.css" /><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

            div.diff-add  { background-color: #FFFF99; }
            div.diff-del  { text-decoration: line-through; }
            div.diff-chg  { background-color: #99FF99; }
            div.diff-off  {  }

            span.diff-add { background-color: #FFFF99; }
            span.diff-del { text-decoration: line-through; }
            span.diff-chg { background-color: #99FF99; }
            span.diff-off {  }

            td.diff-add   { background-color: #FFFF99; }
            td.diff-del   { text-decoration: line-through }
            td.diff-chg   { background-color: #99FF99; }
            td.diff-off   {  }
         
       code.function { font-weight: bold; }
      code.type { font-style: italic; } body { background-image: url(http://expath.org/images/logo-candidate.png); } </style></head><body><div><p>The presentation of this document has been augmented to
            identify changes from a previous version. Three kinds of changes
            are highlighted: <span class="diff-add">new, added text</span>,
            <span class="diff-chg">changed text</span>, and
            <span class="diff-del">deleted text</span>.</p><hr /></div><p><a href="http://w3.org/"><img src="http://w3.org/Icons/w3c_home" alt="W3C" height="48" width="72" /></a></p><div class="head">
<h1><a name="title" id="title"></a>Archive Module</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>EXPath Candidate Module 12 May 2014</h2><dl><dt>This version:</dt><dd>
      <span class="diff-chg"><a href="http://expath.org/spec/archive/20140512">http://expath.org/spec/archive/20140512</a></span><br />
    </dd><dt>Latest version:</dt><dd>
      <a href="http://expath.org/spec/archive">http://expath.org/spec/archive</a><br />
    </dd><dt>Previous versions:</dt><dd>
      <span class="diff-add"><a href="http://expath.org/spec/archive/20131205">http://expath.org/spec/archive/20131205</a></span><br />
      <a href="http://expath.org/spec/archive/20130930">http://expath.org/spec/archive/20130930</a><br />
      <a href="http://expath.org/spec/zip/20101012">http://expath.org/spec/zip/20101012</a><br />
    </dd><dt>Editor:</dt><dd>John Lumley, Saxonica Ltd &lt;<a href="mailto:john@saxonica.com">john@saxonica.com</a>&gt;</dd><dt>Contributors:</dt><dd>Christian Grün, BaseX GmbH &lt;<a href="mailto:christian.gruen@gmail.com">christian.gruen@gmail.com</a>&gt;</dd><dd>Matthias Brantner, 28msec GmbH &lt;<a href="mailto:matthias.brantner@28msec.com">matthias.brantner@28msec.com</a>&gt;</dd><dd>Florent Georges, H2O Consulting</dd></dl><p>This document is also available in these non-normative formats: <span class="diff-chg"><a href="http://expath.org/spec/archive/20140512.xml">XML</a></span>.</p><p class="copyright">Copyright © 2014 John Lumley, Christian Grün, Matthias Brantner and Florent Georges,
        published by the <a href="http://w3.org/community/expath/">EXPath Community Group</a>
        under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community
          Contributor License Agreement (CLA)</a>. A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is
        available.</p><p class="copyright">This specification was published by the <a href="http://www.w3.org/community/expath/">EXPath Community Group</a>. It is not a W3C Standard nor is it on the W3C Standards
        Track. Please note that under the <a href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License
          Agreement (CLA)</a> there is a limited opt-out and other conditions apply. Learn more
        about <a href="http://www.w3.org/community/">W3C Community and Business Groups</a>.</p></div><hr /><div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2><p>This proposal provides an API for XPath 2.0 and XPath 3.0 to handle archive data (i.e.
        collected and possibly compressed sets of files and directories). It defines extension
        functions to process data from and to such archives files, including creation, determining
        and setting properties, listing and extracting contents and adding and updating entries. It
        has been designed to be compatible with XQuery 1.0 and XSLT 2.0, as well as any other XPath
        2.0 usage. Some additional features for use in XPath 3.0 are also defined.</p></div><div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2><p class="toc">1 <a href="#status">Status of this document</a><br />
2 <a href="#introduction">Introduction</a><br />
    2.1 <a href="#d6e135">Namespace conventions</a><br />
    2.2 <a href="#d6e190">Error management</a><br />
    2.3 <a href="#type">Archive representation</a><br />
    2.4 <a href="#archive.types">Archive types</a><br />
    2.5 <a href="#d6e284">Optional interfaces</a><br />
3 <a href="#use-cases">Use cases</a><br />
    3.1 <a href="#example.epub">Creating a simple EPUB document</a><br />
    3.2 <a href="#example.jar">Examining a JAR file</a><br />
    3.3 <a href="#example.zip.to">Extracting a ZIP archive to a file system</a><br />
    3.4 <a href="#example.zip.from">Creating a ZIP archive from a file tree</a><br />
4 <a href="#descriptions">Describing archives and entries</a><br />
    4.1 <a href="#archive.properties">Archive properties and options</a><br />
    4.2 <a href="#entry.structures">Entry descriptions</a><br />
5 <a href="#loading">Loading and saving archives</a><br />
6 <a href="#information">Information about an archive and its contents</a><br />
    6.1 <a href="#fn.options">arch:options</a><br />
    6.2 <a href="#fn.entry.names.map">arch:entry-names</a><br />
    6.3 <a href="#fn.entries">arch:entries</a><br />
7 <a href="#extraction">Extracting entries from an archive</a><br />
    7.1 <a href="#fn.extract.binary">arch:extract-binary</a><br />
    7.2 <a href="#fn.extract.text">arch:extract-text</a><br />
8 <a href="#updating">Updating entries in an archive</a><br />
    8.1 <a href="#fn.delete">arch:delete</a><br />
    8.2 <a href="#fn.update">arch:update</a><br />
9 <a href="#creating">Creating an archive</a><br />
    9.1 <a href="#fn.create">arch:create</a><br />
10 <a href="#extracting">Creating and extracting complete archives<span class="diff-add"> from and to file
          systems</span></a><br />
    10.1 <a href="#fn.from.files">arch:from-files</a><br />
    10.2 <a href="#fn.to.files">arch:to-files</a><br />
11 <a href="#convenience">Convenience functions</a><br />
    11.1 <a href="#fn.text">arch:text</a><br />
    11.2 <a href="#fn.xml">arch:xml</a><br />
12 <a href="#maps">Functions using XSLT3.0 map() type</a><br />
    12.1 <a href="#using.maps">Using map types to describe entries and options</a><br />
        12.1.1 <a href="#archive.options.map">Archive property maps</a><br />
        12.1.2 <a href="#entry.structures.map">Entry property maps</a><br />
    12.2 <a href="#fn.options.map">arch:options-map</a><br />
    12.3 <a href="#fn.entries.map">arch:entries-map</a><br />
    12.4 <a href="#fn.extractmap">arch:extract-map</a><br />
    12.5 <a href="#fn.extract.binary.map">arch:extract-binary-map</a><br />
    12.6 <a href="#fn.extract.text.map">arch:extract-text-map</a><br />
    12.7 <a href="#fn.create.map">arch:create-map</a><br />
    12.8 <a href="#fn.update.map">arch:update-map</a><br />
    12.9 <a href="#fn.delete.map">arch:delete-map</a><br />
</p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3><p class="toc">A <a href="#references">References</a><br />
B <a href="#errors">Summary of error conditions</a><br />
</p></div><hr /><div class="body"><div class="div1">
<h2><a name="status" id="status"></a>1 Status of this document</h2><p>This document is in an interim draft stage. Comments are welcomed at <a href="mailto:public-expath@w3.org">public-expath@w3.org</a> mailing list (<a href="http://lists.w3.org/Archives/Public/public-expath/">archive</a>).</p></div><div class="div1">
<h2><a name="introduction" id="introduction"></a>2 Introduction</h2><div class="div2">
<h3><a name="d6e135" id="d6e135"></a>2.1 Namespace conventions</h3><p>The module defined by this document defines several functions, all contained in the
          namespace <code>http://expath.org/ns/archive</code>. In this document, the
            <code>arch</code> prefix, when used, is bound to this namespace URI.</p><div class="diff-del"><p>Alternative versions of these functions using the proposed XPath3.0
            <code>map()</code> type (see <a href="#using.maps"><b>12.1 Using map types to describe entries and options</b></a>) are defined in the namespace
            <code>http://expath.org/ns/archive-map</code>. In this document, the <code>archM</code>
          prefix, when used, is bound to this namespace URI. </p></div><p>Error codes are defined in the same namespace
          (<code>http://expath.org/ns/archive</code>), and in this document are displayed with the
          same prefix, <code>arch</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This follows the suggestion (in late August 2013) for a coherent naming standard in
            EXPath modules.</p></div><p>Binary file I/O, to read and write complete archives to files, uses facilities defined in
            <a href="#expathfile">[EXPath File]</a>, which defines functions in the namespace
            <code>http://expath.org/ns/file</code>. In this document, the <code>file</code> prefix,
          when used, is bound to this namespace URI.</p><p>Manipulation of binary data itself can employ functions from <a href="#expathbinary">[EXPath Binary]</a>, which defines functions in the namespace <code>http://expath.org/ns/binary</code>. In
          this document, the <code>bin</code> prefix, when used, is bound to this namespace URI.</p></div><div class="div2">
<h3><a name="d6e190" id="d6e190"></a>2.2 Error management</h3><p>Error conditions are identified by a code (a <code>QName</code>.) When such an error
          condition is reached in the evaluation of an expression, a dynamic error is thrown, with
          the corresponding error code (as if the standard XPath function <code>error()</code> had
          been called.) The namespace of the code follows that of the module within whose processing
          the error occurs, i.e. <code>http://expath.org/ns/archive</code> for errors in archive
          manipulation, <code>http://expath.org/ns/file</code> for errors in file operations and
            <code>http://expath.org/ns/binary</code> for errors in processing binary data.</p></div><div class="div2">
<h3><a name="type" id="type"></a>2.3 Archive representation</h3><p>Archives in this module are represented principally as items of type
            <code>xs:base64Binary</code>, i.e. in their basic binary (byte sequence) forms.</p><p>Archives are treated as being arranged structurally as a description of overall options
          of the archive and a sequence of named entries. Each entry has:</p><ul><li><p>A <b>name</b>, which is treated as a sequence of Unicode characters. In many cases
              the solidus character (<code>/</code>) is used to imply the entries being logically
              arranged in positions within a directory tree, but this is not mandatory.</p></li><li><p>A set of <b>properties</b>, denoting at least the uncompressed size of the entry,
              archive internal properties for the entry, such as the compression method used on the
              stored data and other indications such as the date of last modification.</p></li><li><p><b>Data</b>, treated as (possibly null) binary data.</p></li></ul><p>It is most common that archives are considered to be arranged logically as directories,
          using the entry names to denote paths and file names (e.g.
            <code>tests/qt3/archive/main.xml</code>) In such circumstances, archives may contain
          entries to represent the directories themselves (e.g. <code>tests/qt3/archive/</code>)
          presumably with no data. [This could be used such that full extraction of an archive to a
          file system generates empty output directories for example.] This specification makes no
          distinction between these two cases – if an archive has an empty 'directory' entry it will
          be treated similarly to any other 'file' entry. <em>Semantic intrepretation of entry
            names as files in directory trees is an application issue.</em></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Behaviour when entries with duplicate names are detected in an archive is
            implementation dependent. Nevertheless, if an error is not thrown, only <em>one</em>
            entry should be returned when reading. Implementations <strong>must not</strong> write
            duplicate entries in result archives.</p></div></div><div class="div2">
<h3><a name="archive.types" id="archive.types"></a>2.4 Archive types</h3><p>The module is designed to be able to support a number of different types of archive,
          providing a coherent access mechanism.</p><p>The following archive types are required to be supported:</p><ul><li><p><a href="#zip">[ZIP]</a>: (which also covers derivative archive formats, such as JAR or
              OpenDocument.)</p></li><li><p><a href="#gzip">[GZIP]</a> : A compressed archive of a sequence of files</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within GZIP names of entries (original file names) are optional, on a per-file
                basis, so special measures may need to be taken to handle 'unnamed' sections.</p></div></li></ul><p>Specific issues arise from i) archives used in streaming situations, where the internal
          manifests of the archives cannot be completed until all data is written, ii) archives
          where the order of entries is important, such as JAR, where the mainfest entries need to
          be first.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Currently there are no proposals within this module to cover encrypted archives.</p></div></div><div class="diff-add"><div class="div2">
<h3><a name="d6e284" id="d6e284"></a>2.5 Optional interfaces</h3><p>This module defines two distinctly different interface schemes for reporting on and
          manipulating archive data. The first uses XML-structured trees to describe entries, their
          names and their properties, leaving (binary) data described in separate arguments to or
          results from the functions defined. All conformant implementations must support this
          interface.</p><p>An alternative interface, using the proposed XPath3.0 <code>map()</code> type (see
            <a href="#maps"><b>12 Functions using XSLT3.0 map() type</b></a>), may be supported by an implementation. This significantly
          increases the coherence of the connection between entries and their data (as binary data
          can be the 'value' of a map entry), at the minor cost of having to specify entry order for
          those archive usages which are order sensitive (e.g. EPUB). This map interface can
          co-exist with the XML-structured one.</p></div></div></div><div class="div1">
<h2><a name="use-cases" id="use-cases"></a>3 Use cases</h2><p>Development of this specification was driven by requirements which some XML developers
        regularly encounter in examining or generating data which is presented in archival forms.
        Some typical use cases include:</p><ul><li><p>Manipulating EPUB documents.</p></li><li><p>Examining Java classes and resources stored in <code>JAR</code> formats.</p></li></ul><div class="div2">
<h3><a name="example.epub" id="example.epub"></a>3.1 Creating a simple EPUB document</h3><p>An <a href="#epub">[EPUB]</a> document is a collection of content sections, written in XHTML,
          with a metadata descriptor (usually the <code>content.opf</code> file) and a navigation
          description (usually the <code>toc.ncx</code> file), all collected together and
          potentially compressed in a ZIP format. A simple example of creating such a document in
          XQuery is:</p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
arch:create(
    (
      "mimetype",
      "META-INF/container.xml",
      "OEBPS/content.opf",
      "OEBPS/Text/title.xhtml",
      "OEBPS/Text/chap01.xhtml",
      "OEBPS/toc.ncx"
    ),
    (
      content:mimetype(),
      content:metainf(),
      content:oebps-content(),
      content:title(),
      content:chapter(),
      content:toc()
    )
  )
</pre></div></div><p>The user-supplied XQuery function <code>content:mimetype()</code> returns the appropriate
          mimetype description for the EPUB document as a <span class="diff-add"><span>base64-encoding of
            a</span></span> string ("application/epub+zip"). Each of the other <code>content:*()</code>
          functions generates a serialized form of the appropriate XML structure again in a base64
          encoding, e.g.:</p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
declare function content:title() as xs:base64Binary
{
  bin:encode-string(fn:serialize(
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
      &lt;title&gt;Title Page&lt;/title&gt;
    &lt;/head&gt;
    
    &lt;body&gt;
      &lt;div&gt;
        &lt;h2 id="heading_id_2"&gt;Sample Book&lt;/h2&gt;
    
        &lt;h2 id="heading_id_3"&gt;A Sample .epub Book&lt;/h2&gt;
    
        &lt;h3 id="heading_id_4"&gt;Title Page&lt;/h3&gt;
      &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  )))
};
</pre></div></div><p><span class="diff-del"><span>Using a map struture to define an entry enables properties such as
            compression to be altered on on entry-by-entry basis. </span></span>For and EPUB document the
          mimetype entry <em>must</em> be uncompressed (so effectively it can be read by simple
          string searching), but other entries may be compressed.</p></div><div class="div2">
<h3><a name="example.jar" id="example.jar"></a>3.2 Examining a JAR file</h3><p>JAR files contain class code and definitions for Java classes, in entries whose names are
              <em><code>path/classname</code></em><code>.class</code>. Local classes (classes
          defined within a class) have separate code entries with a classname
              <em><code>outerclass</code></em><code>$</code><em><code>innerclass</code></em>.
          To find all the main package-qualified classes the following XPath should suffice: </p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
for $e in arch:entry-names(file:read-binary("lib/saxon9-sql.jar"))[ends-with(.,'.class') and not(contains(.,'$'))] 
  return replace(replace($e,'\.class$',''),'/','.')
=&gt; 
   "net.sf.saxon.option.sql.SQLClose", 
   "net.sf.saxon.option.sql.SQLColumn", 
   "net.sf.saxon.option.sql.SQLConnect",
   ....,
   "net.sf.saxon.option.sql.SQLUpdate" 
</pre></div></div></div><div class="diff-del"><div class="div2">
<h3><a name="example.zip.to" id="example.zip.to"></a>3.3 Extracting a ZIP archive to a file system</h3><p>The following XSLT function will unzip an archive to the current directory, using the
          file writing functions of <a href="#expathfile">[EXPath File]</a>: </p><div class="exampleInner"><pre>
&lt;xsl:function name="arch:extract-to-files"&gt;
    &lt;xsl:param name="archive" as="xs:base64Binary"/&gt;
    &lt;xsl:variable name="entries" select="arch:entries($archive)"/&gt;
    &lt;xsl:variable name="dirs" select="$entries[ends-with(.,'/')]"/&gt;
    &lt;xsl:variable name="required.dirs"
        select="distinct-values(for $r in ($entries except $dirs) 
                  return replace($r,'/[^/]+$','/'))[ends-with(.,'/')]"/&gt;
    &lt;xsl:sequence
        select="for $d in distinct-values(($required.dirs,$dirs)) 
                return file:create-dir(replace($d,'/$',''))"/&gt;
    &lt;xsl:sequence
        select="for $f in ($entries except $dirs) 
                return file:write-binary($f,arch:extract-binary($archive,$f))"/&gt;
&lt;/xsl:function&gt;
</pre></div><p>The function will create empty directories described but not filled in the archive.
            <code>file:create-dir()</code> creates necessary intermediate directories, so
            <code>$dirs</code> does not need to be in a sorted order.</p></div></div><div class="diff-del"><div class="div2">
<h3><a name="example.zip.from" id="example.zip.from"></a>3.4 Creating a ZIP archive from a file tree</h3><p>The following XSLT function will create an archive from files and (recursive) directories
          named relative to the current directory, using the file reading functions of <a href="#expathfile">[EXPath File]</a>: </p><div class="exampleInner"><pre>
&lt;xsl:function name="arch:from-files" as="xs:base64Binary"&gt;
    &lt;xsl:param name="files" as="xs:string*"/&gt;
    &lt;xsl:variable name="all" as="xs:string*"
      select="for $f in $files return if(file:is-dir($f)) then (for $f1 in file:list($f,true()) return concat($f,$f1)) else $f"/&gt;
    &lt;xsl:variable name="normalized.names" select="for $n in $all return replace($n,'\\','/')"/&gt;
    &lt;xsl:variable name="content" as="xs:base64Binary*"
      select="for $f in $normalized.names return if(file:is-dir($f)) then xs:base64Binary('') else file:read-binary($f)"/&gt;
    &lt;xsl:sequence select="arch:create($normalized.names,$content)"/&gt;
&lt;/xsl:function&gt;
</pre></div></div></div></div><div class="div1">
<h2><a name="descriptions" id="descriptions"></a>4 Describing archives and entries</h2><p>The properties of overall archives and individual entries at the XDM level are described by
        small structured elements, with optional information attached. <span class="diff-del"><em>In this
          proposal this information is attached as attributes.</em></span><span class="diff-add"><em>In common with
          description of serialization parameters, these i) use child elements as the property key
          and ii) place scalar values as the <code>@value</code> attribute of that child.</em></span></p><div class="diff-del"><div class="note"><p class="prefix"><b>Note:</b></p><p>Parallels with XPath 3.0 serialization parameters, which are now sets of (element) nodes,
          become awkward. In <code>arch:entry</code> we would need to add an element
            <code>arch:name</code> to hold the name of an entry, rather than rely on the string
          value. The major point in favour of using elements rather than attributes would be where
          we need to read or set complex structured parameters, such as character maps. This needs
          discussion.</p></div></div><div class="div2">
<h3><a name="archive.properties" id="archive.properties"></a>4.1 Archive properties and options</h3><p>Archive options and properties are described as a structured element
            (<code>element(arch:options)</code>) with the following <span class="diff-del"><span>attributes</span></span><span class="diff-add"><span>child elements, all of whose values are described
            in their <code>@value</code> attribute</span></span>:</p><ul><li><p><span class="diff-chg"><b>arch:format</b></span>: the type of the archive, e.g. "zip". This is
              mandatory.</p></li><li><p><span class="diff-chg"><b>arch:algorithm</b></span>: the default compression used in the archive, e.g.
              "deflate".</p></li></ul><p>Other attributes may be dependent upon the type of the archive and the
          implementation.</p></div><div class="div2">
<h3><a name="entry.structures" id="entry.structures"></a>4.2 Entry descriptions</h3><p>Entries within the archive can be accessed by name (<code>xs:string</code>) or a
          structured element (<code>element(arch:entry)</code>). In the latter case the entry name
          is the <span class="diff-del"><span>string</span></span>
          <span class="diff-add"><span>value of the <code>@value</code> attribute of the
              <code>arch:name</code> child.</span></span></p><p>When describing an existing entry in an archive, <code>element(arch:entry)</code> may be
          returned with the following (optional) <span class="diff-del"><span>attributes</span></span>
          <span class="diff-add"><span>children, all of whose values are described in the <code>@value</code>
            attribute</span></span>:</p><ul><div class="diff-add"><li><p><b>arch:name</b>: the (path) name of the entry. <strong>REQUIRED</strong></p></li></div><li><p><span class="diff-chg"><b>arch:size</b></span>: the original file size of the entry.</p></li><li><p><span class="diff-chg"><b>arch:compressed-size</b></span>: the compressed file size of the entry, i.e.
              the number of bytes it occupies in the archive.</p></li><li><p><span class="diff-chg"><b>arch:last-modified</b></span>: the date of last modification of this entry,
              in <code>xs:dateTime</code> notation.</p></li><li><p><span class="diff-chg"><b>arch:compression-level</b></span>: an indicator of the level of (lossless?)
              compression.</p></li></ul><p>When used to create or update an entry in an archive, <code>element(arch:entry)</code>
          may also have the following (optional) <span class="diff-del"><span>attributes</span></span>
          <span class="diff-add"><span>children</span></span>:</p><ul><div class="diff-add"><li><p><b>arch:name</b>: the (path) name of the entry. <strong>REQUIRED</strong></p></li></div><li><p><span class="diff-chg"><b>arch:last-modified</b></span>: the date of last modification to be written
              on this entry, in <code>xs:dateTime</code> notation.</p></li><li><p><span class="diff-chg"><b>arch:compression-level</b></span>: the level of (lossless?) compression to
              be used in writing the entry into the archive.</p></li><li><p><span class="diff-chg"><b>arch:encoding</b></span>: the encoding to be used for converting textual
              items to a byte sequence, prior to possible compression and writing to the archive.
                <span class="diff-add"><span>The only values which every implementation is
                  <strong>required</strong> to recognize are <code>utf-8</code> and
                  <code>utf-16</code></span></span></p></li></ul><p>(In writing actions, unknown <span class="diff-del"><span>attributes</span></span>
          <span class="diff-add"><span>children</span></span> are ignored.<span class="diff-add"><span> In the case of
            duplicate children, the value of the <em>first</em> child is taken.</span></span>)</p></div></div><div class="div1">
<h2><a name="loading" id="loading"></a>5 Loading and saving archives</h2><p>This module defines no specific functions for reading and writing archives from files, as
        distinct from their binary data. The EXPath File Module <a href="#expathfile">[EXPath File]</a> provides
        two suitable functions to do this:</p><ul><li><p>
            <code class="function"><a href="http://expath.org/spec/file#d3e954">file:read-binary</a></code>($file as <code class="type">xs:string</code>) as
              <code class="type">xs:base64Binary</code>. Returns the content of a file in its Base64
            representation.</p></li><li><p>
            <code class="function"><a href="http://expath.org/spec/file#d3e1359">file:write-binary</a></code>($file as <code class="type">xs:string</code>, $value as
              <code class="type">xs:base64Binary</code>) as <code class="type">empty-sequence()</code>. Writes a
            Base64 item as binary to a file. </p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><div class="diff-del"><p>There may be some desire for some convenience functions <code>arch:write($file
            as <code class="type">xs:string</code>,....) as empty-sequence()</code> which does creation and
          file writing as one action.</p></div><div class="diff-add"><p>The functions detailed in <a href="#fn.to.files"><b>10.2 arch:to-files</b></a> and <a href="#fn.from.files"><b>10.1 arch:from-files</b></a> may be used to transfer between file system directory trees and
          archives in a single operation.</p></div></div></div><div class="div1">
<h2><a name="information" id="information"></a>6 Information about an archive and its contents</h2><div class="div2">
<h3><a name="fn.options" id="fn.options"></a>6.1 arch:options</h3><dl><dt class="label">Summary</dt><dd><p>Returns a description of the type and properties of a given archive. </p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:options</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">element(arch:options)*</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>The description is returned as an element <code>&lt;arch:options&gt;</code> with an
                unordered sequence of child elements describing the details. The following are
                currently supported:</p><ul><li><code>arch:format</code>: format of this archive</li><li><code>arch:algorithm</code>: the compression algorithm that was used.</li></ul><p>If the archive format supports a compression algorithm varying on a per-entry
                basis, and more than one algorithm has been used in the archive, <code>mixed</code>
                is returned for <code>arch:algorithm</code>.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem
                in reading the archive.</p></dd><dt class="label">Examples</dt><dd><p>Finding the properties of the archive stored in a file located at
                <code>$uri</code>:</p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
arch:options(file:read-binary($uri))
=&gt; &lt;arch:options&gt;
     &lt;arch:format value="ZIP"/&gt;
     &lt;arch:algorithm value="deflate"/&gt;
   &lt;/arch:options&gt;</pre></div></div></dd></dl></div><div class="diff-add"><div class="div2">
<h3><a name="fn.entry.names.map" id="fn.entry.names.map"></a>6.2 arch:entry-names</h3><dl><dt class="label"><span class="diff-add">Summary</span></dt><dd><div class="diff-add"><p>Returns the entry names for all the entries found within the archive as a sequence
                of string values in the order in which they appear in the archive.</p></div></dd><dt class="label"><span class="diff-add">Signature</span></dt><dd><div class="diff-add"><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:entry-names</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></div></div></p></div></dd><dt class="label"><span class="diff-add">Rules</span></dt><dd><div class="diff-add"><p>Returns the entry names for all the entries found within the archive as a sequence
                of string values in the order in which they appear in the archive.</p></div></dd><dt class="label"><span class="diff-add">Error Conditions</span></dt><dd><div class="diff-add"><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem
                in reading the archive.</p></div></dd></dl></div></div><div class="div2">
<h3><a name="fn.entries" id="fn.entries"></a>6.3 arch:entries</h3><dl><dt class="label">Summary</dt><dd><p>Returns the set of entry descriptors for all the entries found within the archive.
              </p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:entries</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">element(arch:entry)*</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>Each descriptor is an element <code>&lt;arch:entry&gt;</code> whose text value is
                the path of the file within the archive. For more details of this structure see
                  <a href="#entry.structures"><b>4.2 Entry descriptions</b></a>.</p><p>The entries are returned in the order in which they encountered serially within the
                archive.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem
                in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>There may be a case for providing a sorted version, probably using some form of
                collation.</p></dd><dt class="label">Examples</dt><dd><p>Finding the entries of the archive stored in a file located at
                <code>$uri</code>:</p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
arch:entries(file:read-binary($uri))
=&gt; &lt;arch:entry&gt;
      &lt;arch:name value="lumley.jpg"/&gt;
      &lt;arch:size value="2194"/&gt;
      &lt;arch:compressed-size value="652"/&gt;
      &lt;arch:last-modified value="2013-07-18T11:22:12"/&gt;
   &lt;/arch:entry&gt;
   &lt;arch:entry size="84983" compressed-size="84872" last-modified="2009-03-23T11:15:06"&gt;lumley.jpg&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </pre></div></div><p>Summing the size of the apparent XML files in the previous example:</p><div class="exampleInner"><pre>
sum(arch:entries(file:read-binary($uri))[ends-with(arch:name/@value,'.xml')]arch:size/@value)
=&gt; 10058
     </pre></div></dd></dl></div></div><div class="div1">
<h2><a name="extraction" id="extraction"></a>7 Extracting entries from an archive</h2><p>The module does not attempt to discern the 'type' of an entry (such as 'text', 'XML',
        'raw-binary'), leaving that to the programmer. Two forms of reading result are supported:
        raw binary (<code>xs:base64Binary</code>) and decoded text (<code>xs:string</code>). </p><div class="div2">
<h3><a name="fn.extract.binary" id="fn.extract.binary"></a>7.1 arch:extract-binary</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as binary data.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-binary</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary*</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns as binary data each entry in the archive <code>$archive</code> that corresponds
                to the entry name input, in sequence.</p><p>The entries <strong>must</strong> be returned in the order corresponding to that
                of the entries requested in <code>$entries</code>, not in the order in which they
                may exist in the archive.</p><p>Multiple requests for the same entry will be honoured, with copies of the entry
                appearing in corresponding multiple locations in the output sequence .</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist
                in this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>There have been suggestions for a signature <code>arch:extract-binary($archive as
                  xs:base64Binary)</code> returning all the entries. In the absence of maps in the
                return type, this does not make sense, since the entries are totally unlabelled, and
                to get anything meaningful, a parallel call on <code>arch:entries()</code> would be
                required.</p></dd><dt class="label">Examples</dt><dd><p>Returning the binary data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:extract-binary(file:read-binary($uri),'build.xml')
=&gt; stuff
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="fn.extract.text" id="fn.extract.text"></a>7.2 arch:extract-text</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as strings. If
                  <code>$encoding</code> is specified the strings are decoded appropriately,
                otherwise UTF-8 encoding is assumed.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns as a string each entry in the archive <code>$archive</code> that corresponds to
                the entry name input, in sequence.</p><p>If <code>$encoding</code> is specified the strings are decoded appropriately,
                otherwise UTF-8 encoding is assumed.</p><p>The entries <strong>must</strong> be returned in the order corresponding to that
                of the entries requested in <code>$entries</code>, not in the order in which they
                may exist in the archive.</p><p>Multiple requests for the same entry will be honoured, with copies of the entry
                appearing in corresponding multiple locations in the output sequence .</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist
                in this archive.</p><p><a href="#error.unknownEncoding">[arch:unknown-encoding]</a> is raised if the encoding requested is
                unknown or unsupported.</p><p><a href="#error.decoding">[arch:decoding-error]</a> is raised if there was an error in decoding the
                entry.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>This function should be equivalent to the use of <code>arch:extract-binary()</code>
                and the function <code>bin:decode-string()</code> from <a href="#expathbinary">[EXPath Binary]</a>:</p><div class="exampleInner"><pre>arch:extract-binary($archive,$entries) ! bin:decode-string(.,$encoding) [XPath
                3.0]</pre></div><div class="exampleInner"><pre>for $b in arch:extract-binary($archive,$entries) return bin:decode-string($b,$encoding)
                [XPath 2.0]</pre></div><p>Further conversion into XML can be achieved using the XPath3.0 function
                  <code>fn:parse-XML()</code> on each of the returned strings.</p><p>There have been suggestions for a signature <code>arch:extract-text($archive as
                  xs:base64Binary)</code> returning all the entries. In the absence of maps in the
                return type, this does not make sense, since the entries are totally unlabelled, and
                to get anything meaningful, a parallel call on <code>arch:entries()</code> would be
                required.</p></dd><dt class="label">Examples</dt><dd><p>Returning the text data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:extract-text(file:read-binary($uri),'build.xml','UTF-8')
=&gt; stuff
     </pre></div></dd></dl></div></div><div class="div1">
<h2><a name="updating" id="updating"></a>8 Updating entries in an archive</h2><p>There are two atomic actions available to change entries within an archive: complete
        deletion of an entry, or complete updating (overwriting) of that entry – the latter adds new
        entries when the given name does not already exist in the archive</p><div class="div2">
<h3><a name="fn.delete" id="fn.delete"></a>8.1 arch:delete</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with the given entries deleted.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:delete</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <code>$archive</code> with all the entries
                named in <code>$entries</code> deleted.</p><p>The relative order of the remaining entries within the archive is preserved.</p><p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p><p>Duplicate entries in <code>$entries</code> are ignored.</p><p>If <code>$entries</code> is the empty sequence, the original archive shall be
                returned.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested for deletion
                does not exist in this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>Whilst the uncompressed entries remaining after deletion should of course be the
                same size and content as those before deletion, depending upon the (lossless)
                compression algorithm used, the compressed sizes and content might not be. In the
                absence of a special check, in these circumstances <code>$archive</code> may not be
                identical to <code>arch:delete($archive,())</code>. This needs discussion. </p></dd><dt class="label">Examples</dt><dd><p>Deleting the entries of the archive stored in a file located at
                <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:entries(arch:delete(file:read-binary($uri),'lumley.jpg'))
=&gt; &lt;arch:entry size="2194" compressed-size="652" last-modified="2013-07-18T11:22:12"&gt;build.xml&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="fn.update" id="fn.update"></a>8.2 arch:update</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with each of the given entries in <code>$entries</code> updated
                to the corresponding values in the sequence <code>$new</code>. If an entry is not
                found, a new entry is added to the end of the archive.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:update</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$new</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="4"><code class="function">arch:update</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$new</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$last-modified</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:dateTime</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <span class="diff-del"><code>$archive</code></span><span class="diff-add"><code>$archive</code></span> with each of the given entries in <code>$entries</code>
                updated to the corresponding value in the sequence <code>$new</code>. If an entry is
                not found, a new entry for it is added to the end of the archive.</p><p>The relative order of all the existing and replaced entries within the archive is
                preserved. New entries appear at the end of the archive in the order in which they
                were specified in the call.</p><p>If specified, and the format supports it, the last-modified date for each of the
                updated entries will be set to <code>$last-modified</code>. In the absence of such a
                parameter, it is implementation-dependent whether last-modified information will be
                written on the updated entries. If such default last-modification is written, it
                should be comparable to the value of <code>fn:current-dateTime()</code> in an XSLT
                environment.</p><p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p><p>The compression methods of the updated entries shall be preserved.</p><p>When duplicate names appear in the entry list, the value of the entry in the
                resulting archive will be that of the value of <code>$new</code> corresponding to
                the <em>last</em> matching entry name. </p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.entryDataMismatch">[arch:entry-data-mismatch]</a> is raised if <code>count($entries) ne
                  count($new)</code>.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading or creating the archive.</p></dd></dl></div></div><div class="div1">
<h2><a name="creating" id="creating"></a>9 Creating an archive</h2><div class="diff-chg"><p>New archives can be created in empty or filled states.</p></div><div class="div2">
<h3><a name="fn.create" id="fn.create"></a>9.1 arch:create</h3><dl><dt class="label">Summary</dt><dd><p>Returns a new archive with each of the given entries in <code>$entries</code> set
                to the corresponding values in the sequence <code>$new</code>.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:create</code>(<code class="arg">$entries</code><code class="as"> as </code><code class="type">xs:string*</code>, <code class="arg">$new</code><code class="as"> as </code><code class="type">xs:base64Binary*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:create</code>(</td><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$new</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$options</code></td><td valign="baseline"><code class="as"> as </code><code class="type">element(arch:options)</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of format specified by <code>$options</code> with each of the
                given entries in <code>$entries</code> set to the corresponding value in the
                sequence <code>$new</code>.</p><p>The relative order of new entries within the archive follows that of the input.</p><p>Content provided for any entry considered to be a directory is ignored.</p><p>When duplicate names appear in the entry list, the value of the entry in the
                resulting archive will be that of the value of <code>$new</code> corresponding to
                the <em>last</em> matching entry name. </p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.entryDataMismatch">[arch:entry-data-mismatch]</a> is raised if <code>count($entries) ne
                  count($new)</code>.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading or creating the archive.</p></dd></dl></div></div><div class="div1">
<h2><a name="extracting" id="extracting"></a>10 Creating and extracting complete archives<span class="diff-add"><span> from and to file
          systems</span></span></h2><div class="div2">
<h3><a name="fn.from.files" id="fn.from.files"></a>10.1 arch:from-files</h3><dl><dt class="label">Summary</dt><dd><p>Collects all the binary file contents from <code>$files</code> and writes them into
                an new archive which is returned.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:from-files</code>(<code class="arg">$files</code><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>Collects all the binary file contents from <code>$files</code> and writes them into
                an new archive which is returned.</p><p>All file content is collected in binary mode, with no attempt at any conversion or
                decoding.</p><p>File and directory path names are normalized to use the solidus ('/') path
                separator.</p><p>Directories are written as empty entries.</p></dd><dt class="label">Error Conditions</dt><dd><p>Error conditions from <a href="#expathfile">[EXPath File]</a> may be raised if there are
                problems on reading from the filesystem, most noteably:</p><ul><li><a href="#error.fileNotFound">[file:not-found]</a> is raised if any of the specified file paths
                  do not exist.</li><li><a href="#error.genericFile">[file:io-error]</a> is raised if any other error occurs.</li></ul></dd><dt class="label">Notes</dt><dd><p>This function should be equivalent to the following XSLT function<span class="diff-del"><span>, already described in <a href="#example.zip.from"><b>3.4 Creating a ZIP archive from a file tree</b></a></span></span>:</p><div class="exampleInner"><pre>
&lt;xsl:function name="arch:from-files" as="xs:base64Binary"&gt;
    &lt;xsl:param name="files" as="xs:string*"/&gt;
    &lt;xsl:variable name="all" as="xs:string*"
      select="for $f in $files return 
                  if(file:is-dir($f)) 
                  then (for $f1 in file:list($f,true()) return concat($f,$f1)) 
                  else $f"/&gt;
    &lt;xsl:variable name="normalized.names" select="for $n in $all return replace($n,'\\','/')"/&gt;
    &lt;xsl:variable name="content" as="xs:base64Binary*"
      select="for $f in $normalized.names return 
                  if(file:is-dir($f)) 
                  then xs:base64Binary('') 
                  else file:read-binary($f)"/&gt;
    &lt;xsl:sequence select="arch:create($normalized.names,$content)"/&gt;
&lt;/xsl:function&gt;
</pre></div><p>This function may be provided by an XSLT package (which will probably use functions
                from <a href="#expathfile">[EXPath File]</a>, and from which appropriate error conditions may be
                propagated, or caught within the package) or by a purpose-built extension function
                that may be able to support such an operation within a context of streaming
                processing.</p></dd></dl></div><div class="div2">
<h3><a name="fn.to.files" id="fn.to.files"></a>10.2 arch:to-files</h3><dl><dt class="label">Summary</dt><dd><p>Extracts all the entries from <code>$archive</code> and writes them into an
                equivalent tree of directories and files in the filesystem at the current
                directory.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:to-files</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">()</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>Extracts all the entries from <code>$archive</code> and writes them into an
                equivalent tree of directories and files in the filesystem at the current
                directory.</p><p>All entries are written in binary mode, with no attempt at any conversion or
                decoding.</p><p>Entry names are considered as file paths, with '/' and '\' separators normalized to
                the path separator for the execution operating system.</p><p>Necessary intermediate directories are created.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p><p>Error conditions from <a href="#expathfile">[EXPath File]</a> may be raised if there are
                problems on writing to the filesystem, most noteably:</p><ul><li><a href="#error.fileExists">[file:exists]</a> is raised if the specified path, or any of its
                  parent directories, points to an existing file. </li><li><a href="#error.noParent">[file:no-dir]</a> is raised if the parent directory of an entry
                  does not exist. (This should not happen.)</li><li><a href="#error.overwriteDirectory">[file:is-dir]</a> is raised if an entry is being written
                  on to an existing directory.</li><li><a href="#error.genericFile">[file:io-error]</a> is raised if any other error occurs.</li></ul></dd><dt class="label">Notes</dt><dd><p>This function should be equivalent to the following XSLT function<span class="diff-del"><span>, already described in <a href="#example.zip.to"><b>3.3 Extracting a ZIP archive to a file system</b></a></span></span>:</p><div class="exampleInner"><pre>
&lt;xsl:function name="arch:to-files"&gt;
    &lt;xsl:param name="archive" as="xs:base64Binary"/&gt;
    &lt;xsl:variable name="entries" select="arch:entries($archive)"/&gt;
    &lt;xsl:variable name="dirs" select="$entries[ends-with(.,'/')]"/&gt;
    &lt;xsl:variable name="required.dirs"
        select="distinct-values(for $r in ($entries except $dirs) return
                                    replace($r,'/[^/]+$','/'))[ends-with(.,'/')]"/&gt;
    &lt;xsl:sequence
        select="for $d in distinct-values(($required.dirs,$dirs)) return 
                    file:create-dir(replace($d,'/$',''))"/&gt;
    &lt;xsl:sequence
        select="for $f in ($entries except $dirs) return 
                    file:write-binary($f,arch:extract-binary($archive,$f))"/&gt;
&lt;/xsl:function&gt;
</pre></div><p>This function may be provided by an XSLT package (which will probably use functions
                from <a href="#expathfile">[EXPath File]</a>, and from which appropriate error conditions may be
                propagated, or caught within the package) or by a purpose-built extension function
                that may be able to support such an operation within a context of streaming
                processing.</p></dd></dl></div></div><div class="diff-add"><div class="div1">
<h2><a name="convenience" id="convenience"></a>11 Convenience functions</h2><p>A small number of convenience functions are defined for common cases of content,
        specifically to ensure that 'empty' entries (empty binary data) are produced for empty
        sequences, to ensure coherence between members of the parallel entry name and entry content
        sequences.</p><div class="div2">
<h3><a name="fn.text" id="fn.text"></a>11.1 arch:text</h3><dl><dt class="label"><span class="diff-add">Summary</span></dt><dd><div class="diff-add"><p>Encodes a string into binary data using a given encoding, suitable for content data
                for an entry.</p></div></dd><dt class="label"><span class="diff-add">Signatures</span></dt><dd><div class="diff-add"><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:text</code>(<code class="arg">$in</code><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></div></div><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:text</code>(<code class="arg">$in</code><code class="as"> as </code><code class="type">xs:string*</code>, <code class="arg">$encoding</code><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></div></div></p></div></dd><dt class="label"><span class="diff-add">Rules</span></dt><dd><div class="diff-add"><p>The <code>$encoding</code> argument is the name of an encoding. The values for this
                attribute follow the same rules as for the <code>encoding</code> attribute in an XML
                declaration. The only values which every implementation is
                  <strong>required</strong> to recognize are <code>utf-8</code> and
                  <code>utf-16</code>.</p><p>If <code>$encoding</code> is ommitted, <code>utf-8</code> encoding is assumed.</p><p>If the value of <code>$in</code> is the empty sequence, the function returns an
                empty binary data. <em>This is unlike <code>bin:encode-string()</code>, which will
                  return an empty sequence</em>.</p></div></dd><dt class="label"><span class="diff-add">Error Conditions</span></dt><dd><div class="diff-add"><p><a href="#error.unknownEncoding">[arch:unknown-encoding]</a> is raised if <code>$encoding</code> is
                invalid or not supported by the implementation.</p><p><a href="#">[error.encoding]</a>is raised if there is an error or malformed input
                during encoding the string. Additional information about the error may be passed
                through suitable error reporting mechanisms – this is implementation-dependant.</p></div></dd></dl></div><div class="div2">
<h3><a name="fn.xml" id="fn.xml"></a>11.2 arch:xml</h3><dl><dt class="label"><span class="diff-add">Summary</span></dt><dd><div class="diff-add"><p>Encodes the serialization of an XML tree into binary data using a given encoding,
                suitable for content data for an entry.</p></div></dd><dt class="label"><span class="diff-add">Signatures</span></dt><dd><div class="diff-add"><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:xml</code>(<code class="arg">$args</code><code class="as"> as </code><code class="type">item()*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:xml</code>(</td><td valign="baseline"><code class="arg">$args</code></td><td valign="baseline"><code class="as"> as </code><code class="type">item()*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$params</code></td><td valign="baseline"><code class="as"> as </code><code class="type">element(output:serialization-parameters)?</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:xml</code>(</td><td valign="baseline"><code class="arg">$args</code></td><td valign="baseline"><code class="as"> as </code><code class="type">item()*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$params</code></td><td valign="baseline"><code class="as"> as </code><code class="type">element(output:serialization-parameters)?</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></div></dd><dt class="label"><span class="diff-add">Rules</span></dt><dd><div class="diff-add"><p>The single-argument version of this function has the same effect as the
                two-argument version called with <code>$params</code> set to an empty sequence. This in turn is
                the same as the effect of passing an <code>output:serialization-parameters</code>
                element with no child elements.</p><p>The <code>$params</code> argument is used to identify a set of serialization
                parameters. These are supplied in the form of an
                  <code>output:serialization-parameters</code> element, having the format described
                in <a href="http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">Section 3.1 Setting Serialization Parameters by Means of a Data Model
                  Instance</a>.</p><p>The <code>$encoding</code> argument is the name of an encoding. The values for this
                attribute follow the same rules as for the <code>encoding</code> attribute in an XML
                declaration. The only values which every implementation is
                  <strong>required</strong> to recognize are <code>utf-8</code> and
                  <code>utf-16</code>.</p><p>If <code>$encoding</code> is ommitted, <code>utf-8</code> encoding is assumed.</p></div></dd><dt class="label"><span class="diff-add">Error Conditions</span></dt><dd><div class="diff-add"><p><a href="#error.unknownEncoding">[arch:unknown-encoding]</a> is raised if <code>$encoding</code> is
                invalid or not supported by the implementation.</p><p><a href="#">[error.encoding]</a>is raised if there is an error or malformed input
                during encoding the string. Additional information about the error may be passed
                through suitable error reporting mechanisms – this is implementation-dependant.</p></div></dd><dt class="label"><span class="diff-add">Notes</span></dt><dd><div class="diff-add"><p>This function is equivalent to
                  <code>arch:text(fn:serialize($args,$params),$encoding)</code>.</p></div></dd></dl></div></div></div><div class="div1">
<h2><a name="maps" id="maps"></a>12 Functions using XSLT3.0 map() type</h2><p>The map type (<code>map(xs:untypedAtomic,item()*)</code>) proposed for XSLT3.0 can increase
        the coherence of the functions in this module significantly, mainly by retaining the
        structured connection between the entry name and its properties and content. In addition the
        properties of the overall archive (and its defaults for new entries) can similarly be
        defined in a single map.</p><p>This section defines optional parallel functions to those above using maps for arguments or
        results. In general these functions have separate names (e.g.
          <code>arch:entries-map()</code>) derived from a consistent suffix ('<code>-map</code>')
        attached to the standard, element-based form.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><code>map:keys($map as map(*)) as xs:anyAtomicType*</code> returns the keys that are
          present in a map, in unpredictable order. This means that if order within an archive is
          important (either in extraction or updating) other mechanisms, such as the
            <b>position</b> property, are needed to track or set that order.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It should be possible to implement all the functions in this section as user-defined
          XSLT3.0 functions using the library described above.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p><em>FOR DISCUSSION</em>. In general when using maps for denoting the entries to be
          manipulated, the arguments could be considered to be a (possibly empty) sequence of maps
          that are treated as if concatentated. [THIS NEEDS THOUGHT ABOUT OVERWRITING/MERGING COMMON
          KEYS]. In this draft the arguments are single maps. </p></div><div class="diff-chg"><div class="div2">
<h3><a name="using.maps" id="using.maps"></a>12.1 Using map types to describe entries and options</h3><p>An archive is described as a map <code>name -&gt; properties</code>, where the properties
          of each entry themselves are represented as a further map. The 'content', i.e. the real
          data, of an archive entry is described by the <b>content</b> property of that map. Thus
          a set of archive entries has type <code>map(xs:string, map(xs:string,item()*))</code></p><p>Support for similar approaches using other map representations, such as <a href="#jsoniq">[JSONiq]</a> objects may be implementation dependent.</p><div class="div3">
<h4><a name="archive.options.map" id="archive.options.map"></a>12.1.1 Archive property maps</h4><p>The properties of an archive itself, as opposed to its entries, can be described or
            defined with a map with the following entries:</p><table cellpadding="5" border="1"><thead><tr><th>Property</th><th>Type</th><th>Meaning</th></tr></thead><tbody><tr><td><b>format</b></td><td><code>xs:string</code></td><td>The format of this archive</td></tr><tr><td><b>compression</b></td><td><code>xs:string</code></td><td>The compression algorithm used for compressing the archive.</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>Using a reserved name within an overall map (such as <code>arch:options</code>) would
              allow the options/properties for an archive to be stored alongside the entries
              themselves.</p></div></div><div class="div3">
<h4><a name="entry.structures.map" id="entry.structures.map"></a>12.1.2 Entry property maps</h4><p>Entries within the archive can be also be accessed or described by entries in a map
              (<code>map(xs:string,map(xs:string,item()*))</code>). In this case the map key gives
            the (path)name of the archive entry (e.g. <code>build/build-j.xml</code>) and the value
            is a map of the properties of that entry.</p><p>The keys are described in the following table, and specific use is described under each
            of the functions:</p><table cellpadding="5" border="1"><thead><tr><th>Property</th><th>Type</th><th>Meaning</th></tr></thead><tbody><tr><td><b>size</b></td><td><code>xs:integer</code></td><td>The original file size of the entry</td></tr><tr><td><b>compressed-size</b></td><td><code>xs:integer</code></td><td>The compressed file size of the entry, i.e. the number of bytes it occupies in
                  the archive</td></tr><tr><td><b>last-modified</b></td><td><code>xs:dateTime</code></td><td>The date of last modification of this entry</td></tr><tr><td><b>compression-level</b></td><td><code>xs:string</code></td><td>An indicator of the level of (lossless?) compression</td></tr><tr><td><b>content</b></td><td><code>xs:base64Binary</code> or <code>xs:string</code></td><td>The value of the entry read from the archive. This will only be set from
                    <code>arch:entries-map()</code> if <code>$return-content</code> is requested in
                  the call. </td></tr><tr><td><b>encoding</b></td><td><code>xs:string</code></td><td>The encoding to be used for converting textual items to or from a byte sequence.
                  The absence of such an entry implies binary content. The only values which every
                  implementation is <strong>required</strong> to recognize are <code>utf-8</code>
                  and <code>utf-16</code></td></tr><tr><td><b>position</b></td><td><code>xs:integer</code></td><td>The position of the entry in the archive, starting at 1.</td></tr></tbody></table></div></div></div><div class="div2">
<h3><a name="fn.options.map" id="fn.options.map"></a>12.2 arch:options-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns a description of the type and properties of a given archive as a map. </p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:options-map</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">map(xs:string,item()?)</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>The description is returned as a map <code>map(xs:string,item()?)</code> with
                entries describing the details. The following are currently supported:</p><ul><li><div class="diff-chg"><b>format</b></div>: format of this archive</li><li><div class="diff-chg"><b>compression</b></div>: the compression algorithm that was
                  used.</li></ul><p>If the archive format supports a compression algorithm varying on a per-entry
                basis, and more than one algorithm has been used in the archive, <code>mixed</code>
                is returned for the <span class="diff-chg"><b>compression</b></span> entry.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem
                in reading the archive.</p></dd><dt class="label">Examples</dt><dd><p>Finding the properties of the archive stored in a file located at
                <code>$uri</code>:</p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
arch:options-map(file:read-binary($uri))
=&gt; map {'format' :'zip', 'compression' : 'deflate'}
</pre></div></div></dd></dl></div><div class="div2">
<h3><a name="fn.entries.map" id="fn.entries.map"></a>12.3 arch:entries-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns the entry descriptors for all the entries found within the archive as a
                map, optionally each with their content.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline"><code class="function">arch:entries-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">map(xs:string,map(xs:string,item()*))</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:entries-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$return-content</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:boolean</code>)<code class="as"> as </code><code class="return-type">map(xs:string,map(xs:string,item()*))</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Keys to the returned map are the entry (path) names.</p><p>The value for each map entry is a map describing the properties of that entry. For
                more details of this structure see <a href="#entry.structures.map"><b>12.1.2 Entry property maps</b></a>. The
                specific properties returned are:</p><div class="diff-add"><ul><li><b>size</b></li><li><b>compressed-size</b></li><li><b>last-modified</b></li><li><b>position</b></li><li><b>content</b>: this will be set only if <code>$return-content</code> is defined
                  and equals <code>true()</code>. The type will be <code>xs:base64Binary</code>.
                </li></ul></div></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem
                in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>As the returned order of keys from <code>map:keys()</code> is not defined and can
                be implementation-dependant, <span class="diff-del"><span>there may be a need for a
                  simple</span></span><span class="diff-add"><span> the results of the</span></span> function
                    <code>arch<span class="diff-del"><span>M</span></span>:entry-names(xs:base64Binary) as
                  xs:string*</code> can be used as a key sequence to iterate through this map, or a
                sort based on the <b>position</b> property.</p><p>Using <code>$return-content</code> makes it possible to return a complete archive
                in a single call. Archive options can be added through a compound shown in the
                examples.</p></dd><dt class="label">Examples</dt><dd><p>Finding the entries of the archive stored in a file located at
                <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:entries-map(file:read-binary($uri))
=&gt; map{ 
  "build.xml" : map{ "size" : 2194, "compressed-size" : 652, "last-modified" : "2013-07-18T11:22:12"},
  "lumley.jpg" : map{ "size" : 84983, "compressed-size" : 84872, "last-modified" : "2009-03-23T11:15:06"},
  "tests/qt3/binary/binary.xml" : map{ "size" : 10058, "compressed-size" : 1381, "last-modified" : "2013-08-06T13:14:08"}}
     </pre></div><p>Counting the number of apparent XML files in the previous example:</p><div class="exampleInner"><pre>
count(map:keys(arch:entries-map(file:read-binary($uri)))[ends-with(.,'.xml')])
=&gt; 2
     </pre></div><p>Returning an archive complete with options:</p><div class="exampleInner"><pre>
map:new((map:new('arch:options',arch:options-map($archive)),arch:entries-map($archive)))
=&gt; map{
  "arch:options" : map{ "format" : "ZIP", "compression" : "flat" },
  "build.xml" : map{ "size" : 2194, "compressed-size" : 652, "last-modified" : "2013-07-18T11:22:12"},
  "lumley.jpg" : map{ "size" : 84983, "compressed-size" : 84872, "last-modified" : "2009-03-23T11:15:06"},
  "tests/qt3/binary/binary.xml" : map{ "size" : 10058, "compressed-size" : 1381, "last-modified" : "2013-08-06T13:14:08"}}
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="fn.extractmap" id="fn.extractmap"></a>12.4 arch:extract-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns a copy of <code>$entries</code> with the content entries set to binary or
                decoded string data for the appropriate entry in the archive.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>)<code class="as"> as </code><code class="return-type">map(xs:string,map(xs:string,item()?))</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Return a copy of <code>$entries</code> with the <b>content</b> property of each
                entry set to binary or decoded string data for the appropriate entry in the
                archive.</p><p>The map entries in <code>$entries</code> define whether binary or decoded string
                data is to be returned. (For details of properties see <a href="#entry.structures.map"><b>12.1.2 Entry property maps</b></a>.) The only relevant property is:</p><ul><li><b>encoding</b>: if this is set, then the entry will be decoded from binary to
                    <code>xs:string</code> according to the named encoding. If absent, then the type
                  will be <code>xs:base64Binary</code>. </li></ul><p>The value for each map entry in the return is the original entry from
                  <code>$entries</code> plus an additional or replaced property:</p><ul><li><b>content</b>: the type will be <code>xs:string</code> or
                    <code>xs:base64Binary</code> dependant upon the presence of the
                    <b>encoding</b> property.</li></ul><p>The behaviour of this function is defined by equivalent XPath:</p><div class="exampleInner"><pre>
map:new(for $k in map:keys($entries) 
   return 
     let $a := $entries($k),
         $text := map:contains($a,'encoding'),
         $encoding := ($a('encoding'),'UTF-8')[1],
         $data := arch:extract-binary($archive,$k) // error if not found
     return 
         map:entry($k,
             map:new(($a,
               map:entry('content',if($text) bin:decode-string($data,$encoding) else $data)
               ))
       )
     </pre></div></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist
                in this archive.</p><p><a href="#error.decoding">[arch:decoding-error]</a> is raised if there was an error in decoding an
                entry.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>As the original <code>$entries</code> are returned in the result map, with content
                added, other information, such as <b>position</b> is retained. </p></dd><dt class="label">Examples</dt><dd><p>To collect all the XML entries as XML:</p><div class="exampleInner"><pre>
let $archive := file:read-binary($uri)
    $entries := arch:entries-map($archive),
    $xml-names := map:keys($entries)[ends-with(.,'.xml')],
    $get := map:new($xml-names ! map:entry(.,map:entry('encoding','UTF-8'))),
    $content := arch:extract-map($archive,$get)
return
    $xml-names ! fn:parse-XML($content(.)('content'))
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="fn.extract.binary.map" id="fn.extract.binary.map"></a>12.5 arch:extract-binary-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as binary data.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-binary-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,item()*)</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary*</code></td></tr></table></div></div></p><div class="diff-del"><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract-binary</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary*</code></td></tr></table></div></div></p></div></dd><dt class="label">Rules</dt><dd><p>Returns as binary data each entry in the archive <code>$archive</code> that corresponds
                to <span class="diff-del"><span>the entry name input, or</span></span>
                <code>map:keys($entries)</code>, in sequence.</p><div class="diff-del"><p>When <code>$entries</code> has type <code>xs:string*</code>, the entries
                  <strong>must</strong> be returned in the order corresponding to that of the
                entries requested in <code>$entries</code>, not in the order in which they may exist
                in the archive.</p></div><div class="diff-del"><p>When <code>$entries</code> has type <code>xs:string*</code>, multiple
                requests for the same entry will be honoured, with copies of the entry appearing in
                corresponding multiple locations in the output sequence .</p></div><div class="diff-add"><p>Any information in the values of each entry of <code>$entries</code> is
                ignored.</p></div></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist
                in this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>Collection of all the entries as binary data can also be accomplished using
                  <code>arch:entries-map($archive,true())</code> and collecting the
                  <code>'content'</code> entry from each of the returned maps.</p></dd></dl></div><div class="div2">
<h3><a name="fn.extract.text.map" id="fn.extract.text.map"></a>12.6 arch:extract-text-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as decoded string
                data.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-text-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:extract-text-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div></p><div class="diff-del"><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">archM:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div></p></div></dd><dt class="label">Rules</dt><dd><p>Returns as decoded string data each entry in the archive <code>$archive</code> that
                corresponds to <code>map:keys($entries)</code>, in sequence.</p><div class="diff-del"><p>When <code>$entries</code> has type <code>xs:string*</code>, the entries
                  <strong>must</strong> be returned in the order corresponding to that of the
                entries requested in <code>$entries</code>, not in the order in which they may exist
                in the archive.</p></div><div class="diff-del"><p>When <code>$entries</code> has type <code>xs:string*</code>, multiple
                requests for the same entry will be honoured, with copies of the entry appearing in
                corresponding multiple locations in the output sequence .</p></div><p>If <code>$encoding</code> is specified, or the property <b>encoding</b> appears
                in the entry in <code>$entries</code>, the strings are decoded according to that
                encoding, otherwise UTF-8 encoding is assumed.</p><p>The behaviour of this function is defined by equivalent XPath:</p><div class="diff-chg"><div class="exampleInner"><pre class="diff-chg">
for $k in map:keys($entries) 
   return 
     let $a := $entries($k),
         $thisEncoding := ($a('encoding'),$encoding,'UTF-8')[1],
         $data := arch:extract-binary($archive,$k) // error if not found
     return 
         bin:decode-string($data,$thisEncoding)
     </pre></div></div></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist
                in this archive.</p><p><a href="#error.unknownEncoding">[arch:unknown-encoding]</a> is raised if an encoding requested is unknown
                or unsupported.</p><p><a href="#error.decoding">[arch:decoding-error]</a> is raised if there was an error in decoding an
                entry.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label"><span class="diff-del">Notes</span></dt><dd><div class="diff-del"><p>The signatures with <code>$entries instance of xs:string*</code> are equivalent to
                  <code>arch:extract-text()</code>.</p></div></dd></dl></div><div class="div2">
<h3><a name="fn.create.map" id="fn.create.map"></a>12.7 arch:create-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns a new archive with each of the given entries named as a key in
                  <code>$entries</code> set to the corresponding value in
                  <code>$entries($key)('content')</code>.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline"><code class="function">arch:create-map</code>(</td><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()*))</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:create-map</code>(</td><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()*))</code>,</td></tr><tr><td valign="baseline"><code class="arg">$options</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,item()*)</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of format specified by <code>$options</code> with each of the
                given entries named as a key in <code>$entries</code> set to the corresponding value
                in <code>$entries($key)('content')</code>, and with other properties defined by
                  <code>$entries($key)(*)</code> or <code>$options</code>.</p><p>The map <code>$options</code> can contain properties both for the archive itself,
                and defaults for each entry. Relevant properties for the archive (see also <a href="#archive.options.map"><b>12.1.1 Archive property maps</b></a>) are:</p><div class="diff-add"><ul><li><b>format</b></li><li><b>compression</b></li></ul></div><div class="diff-add"><p>Relevant properties for entries (see also <a href="#entry.structures.map"><b>12.1.2 Entry property maps</b></a>)
                are:</p></div><div class="diff-add"><ul><li><b>compression-level</b></li><li><b>last-modified</b></li><li><b>position</b>: position order for entries. These need not be contiguous, but
                  should not be duplicated. </li><li><b>encoding</b>. If this is set, then the <b>content</b> entry will be encoded
                  from <code>xs:string</code> to binary according to the named encoding. If absent,
                  then <b>content</b> is assumed of type <code>xs:base64Binary</code>. The only
                  values which every implementation is <strong>required</strong> to recognize are
                    <code>utf-8</code> and <code>utf-16</code>.</li><li><b>content</b>: the content to write, treated either as <code>xs:string</code>
                  or <code>xs:base64Binary</code>, dependent upon <b>encoding</b>.</li></ul></div><div class="diff-add"><p>The relative order of entries within the archive follows that of the
                  <b>position</b> property, if specified, followed by all those lacking such a
                property, in an implementation-dependant order. The specific ordering is equivalent
                to:</p></div><div class="diff-add"><div class="exampleInner"><pre class="diff-add">
&lt;xsl:variable name="$keys" select="map:keys($entries)"/&gt;
&lt;xsl:variable name="positioned" as="xs:string*"&gt;
  &lt;xsl:perform-sort select="$keys[map:contains($entries(.),'position']"&gt;
    &lt;xsl:sort select="$entries(.)('position')"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:variable&gt;
&lt;xsl:for-each select="$positioned, $keys[not(.=$positioned)]"&gt;
      .... process ....
&lt;/xsl:for-each&gt;
     </pre></div></div><p>If <code>$options</code> is specified, the overall archive properties (and defaults
                for the entries) are set to those specified in the map.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in creating the archive.</p><div class="diff-add"><p><a href="#error.duplicatePosition">[arch:duplicate-position]</a> is raised if two or more entries request
                the same position in the archive.</p></div></dd></dl></div><div class="div2">
<h3><a name="fn.update.map" id="fn.update.map"></a>12.8 arch:update-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with each of the given entries in the keys of
                  <code>$entries</code> updated to the corresponding values in the
                  <code>$entries($key)('content')</code> and with other properties defined by
                  <code>$entries($key)(*)</code>. If an entry is not found, a new entry is added to
                the end of the archive.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:update-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()*))</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:update-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()*))</code>,</td></tr><tr><td valign="baseline"><code class="arg">$default.options</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,item()*)</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <code>$archive</code> with each of the
                given entries in the keys of <code>$entries</code> updated to the corresponding
                values in the <code>$entries($key)('content')</code> and with other properties
                defined by <code>$entries($key)(*)</code> or <code>$default.options</code>. If an
                entry is not found, a new entry is added to the end of the archive. Relevant
                properties (see also <a href="#entry.structures.map"><b>12.1.2 Entry property maps</b></a>) are:</p><div class="diff-add"><ul><li><b>compression-level</b></li><li><b>last-modified</b></li><li><b>position</b>: position order for new (as opposed to updated) entries. These
                  need not be contiguous, but should not be duplicated. </li><li><b>encoding</b>. If this is set, then the <b>content</b>entry will be encoded
                  from <code>xs:string</code> to binary according to the named encoding. If absent,
                  then <b>content</b> is assumed of type <code>xs:base64Binary</code>. The only
                  values which every implementation is <strong>required</strong> to recognize are
                    <code>utf-8</code> and <code>utf-16</code>.</li><li><b>content</b>: the content to write, treated either as <code>xs:string</code>
                  or <code>xs:base64Binary</code>, dependent upon <b>encoding</b>.</li></ul></div><p>If <code>$options</code> is specified, values will be used for the default
                properties for each entry, which may be overloaded by the property map for each
                individual entry.</p><p>The relative order of all the existing and replaced entries within the archive is
                preserved. New entries appear at the end of the archive:<span class="diff-add"><span> any which have a
                  <b>position</b> property specified, are ordered according to that property,
                followed by any others in an implementation-dependent order</span></span>.</p><p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p><p>The compression methods of the updated entries shall be preserved.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading or creating the archive.</p><div class="diff-add"><p><a href="#error.duplicatePosition">[arch:duplicate-position]</a> is raised if two or more entries request
                the same position in the archive.</p></div></dd><dt class="label">Notes</dt><dd><p>Using the <code>$default</code> map a common compression method, last-modification
                date and similar can be set for a set of entries, whose minimal map entries are
                  <code>map{"content":=$content}</code>
              </p></dd></dl></div><div class="div2">
<h3><a name="fn.delete.map" id="fn.delete.map"></a>12.9 arch:delete-map</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with the given entries deleted.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:delete-map</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,item()*)</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <code>$archive</code> with all the entries
                named in <span class="diff-del"><span><code>$entries</code> or <code>$entries!map:keys(.)</code></span></span><span class="diff-add"><span><code>map:keys($entries)</code></span></span> deleted.</p><p>The relative order of the remaining entries within the archive is preserved.</p><p>The uncompressed content, size and last-modified date of the remaining entries
                shall be the same as those for those entries before deletion. Compressed sizes may
                alter.</p><p>If <code>$entries</code> is an empty map, the original archive shall be
                returned.</p><p>Any information in the values of each entry of <code>$entries</code> is
                ignored.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested for deletion
                does not exist in this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified
                problem in reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>Whilst the uncompressed entries remaining after deletion should of course be the
                same size and content as those before deletion, depending upon the (lossless)
                compression algorithm used, the compressed sizes and content might not be. In the
                absence of a special check, implied in the rules,<code>$archive</code> may not be
                identical to <code>arch:delete-map($archive,map:new())</code>.</p></dd></dl></div></div></div><div class="back"><div class="div1">
<h2><a name="references" id="references"></a>A References</h2><dl><dt class="label"><a name="epub" id="epub"></a>EPUB</dt><dd>
          <a href="http://www.idpf.org/epub/30/spec/epub30-overview.html">EPUB 3 Overview</a>.
          International Digital Publishing Forum. Recommended Specification 11 October 2011.</dd><dt class="label"><a name="expathfile" id="expathfile"></a>EXPath File</dt><dd>
          <a href="http://expath.org/spec/file">File Module</a>. Christian Grün and Matthias
          Brantner, editors. EXPath Candidate Module. 14 June 2012.</dd><dt class="label"><a name="expathbinary" id="expathbinary"></a>EXPath Binary</dt><dd>
          <a href="http://expath.org/spec/binary">Binary Module</a>. Jirka Kosek and John
          Lumley, editors. EXPath Module. 3 December 2013.</dd><dt class="label"><a name="fo30" id="fo30"></a>F&amp;O 3.0</dt><dd>
          <a href="http://www.w3.org/TR/xpath-functions-30/">XPath and XQuery Functions and
            Operators 3.0</a>. Michael Kay, editor. W3C Candidate Recommendation 21 May
          2013.</dd><dt class="label"><a name="gzip" id="gzip"></a>GZIP</dt><dd>
          <a href="http://www.gzip.org/zlib/rfc-gzip.html">GZIP file format specification version
            4.3</a>. L. Peter Deutsch, 1996.</dd><dt class="label"><a name="jsoniq" id="jsoniq"></a>JSONiq</dt><dd>
          <a href="http://www.jsoniq.org/">JSONiq – The JSON Query Language</a>. FLWOR
          Foundation. 2013.</dd><dt class="label"><a name="xmlschema1.1" id="xmlschema1.1"></a>XML Schema 1.1 Part 2</dt><dd>
          <a href="http://www.w3.org/TR/xmlschema11-2/">W3C XML Schema Definition Language (XSD)
            1.1 Part 2: Datatypes</a>. David Peterson et al, editors.W3C Recommendation 5 April
          2012.</dd><dt class="label"><a name="zip" id="zip"></a>ZIP</dt><dd>
          <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">ZIP File Format
            Specification</a>.PKWare, Version 6.3.3, 1 September 2012.</dd></dl></div><div class="div1">
<h2><a name="errors" id="errors"></a>B Summary of error conditions</h2><dl><dt class="label"><a name="error.archiveReadError" id="error.archiveReadError"></a>arch:read-error</dt><dd>There was an general error in
          reading the archive</dd><dt class="label"><a name="error.unknownEntry" id="error.unknownEntry"></a>arch:unknown-entry</dt><dd>The specified entry does not exist in
          this archive.</dd><dt class="label"><a name="error.entryDataMismatch" id="error.entryDataMismatch"></a>arch:entry-data-mismatch</dt><dd>The sequence of entry
          names is not the same length as the sequence of updated values.</dd><dt class="label"><a name="error.unknownEncoding" id="error.unknownEncoding"></a>arch:unknown-encoding</dt><dd>The specified encoding is not
          supported.</dd><dt class="label"><a name="error.decoding" id="error.decoding"></a>arch:decoding-error</dt><dd>Error in decoding a string.</dd><dt class="label"><span class="diff-add"><a name="error.duplicatePosition"></a>arch:duplicate-position</span></dt><dd><div class="diff-add">Two entries are
          requesting the same order position in the archive.</div></dd></dl><p>Errors possibly generated by code executed from module <a href="#expathfile">[EXPath File]</a>:</p><dl><dt class="label"><a name="error.fileNotFound" id="error.fileNotFound"></a>file:not-found</dt><dd>The specified path does not exist.</dd><dt class="label"><a name="error.fileExists" id="error.fileExists"></a>file:exists</dt><dd>The specified path already exists.</dd><dt class="label"><a name="error.noParent" id="error.noParent"></a>file:no-dir</dt><dd>The specified path does not point to a
          directory.</dd><dt class="label"><a name="error.overwriteDirectory" id="error.overwriteDirectory"></a>file:is-dir</dt><dd>The specified path points to a
          directory.</dd><dt class="label"><a name="error.genericFile" id="error.genericFile"></a>file:io-error</dt><dd>A generic file system error
          occurred.</dd></dl></div></div><script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
         </script><script type="text/javascript">
            try {
               var pageTracker = _gat._getTracker("UA-5463082-2");
               pageTracker._trackPageview();
            } catch(err) {}
         </script></body></html>