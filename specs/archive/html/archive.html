<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Archive Module</title><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/base.css" /><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

      code.function { font-weight: bold; }
      code.type { font-style: italic; }
      /* h1, h2, h3 { color: #84001C; background: white } */
      /* a, :link, :visited, a:active { color: #84005C; background: white } */
      body {
        background-image: url(http://expath.org/images/logo-candidate.png);
      }
   </style></head><body><p><a href="http://w3.org/"><img src="http://w3.org/Icons/w3c_home" alt="W3C" height="48" width="72" /></a></p><div class="head">
<h1><a name="title" id="title"></a>Archive Module</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>EXPath Candidate Module 26 September 2013</h2><dl><dt>This version:</dt><dd>
         <a href="http://expath.org/spec/archive/20130926">http://expath.org/spec/archive/20130926</a>
      </dd><dt>Latest version:</dt><dd>
         <a href="http://expath.org/spec/archive">http://expath.org/spec/archive</a>
      </dd><dt>Previous version:</dt><dd>
         <a href="http://expath.org/spec/zip/20101012">http://expath.org/spec/zip/20101012</a><br />
      </dd><dt>Editor:</dt><dd>John Lumley, Saxonica Ltd &lt;<a href="mailto:john@saxonica.com">john@saxonica.com</a>&gt;</dd><dt>Contributors:</dt><dd>Christian Grün, BaseX GmbH &lt;<a href="mailto:christian.gruen@gmail.com">christian.gruen@gmail.com</a>&gt;</dd><dd>Matthias Brantner, 28msec GmbH &lt;<a href="mailto:matthias.brantner@28msec.com">matthias.brantner@28msec.com</a>&gt;</dd><dd>Florent Georges, H2O Consulting</dd></dl><p>This document is also available in these non-normative formats: <a href="http://expath.org/spec/archive/20130926.xml">XML</a>.</p><p class="copyright">Copyright © 2013 John Lumley, Christian Grün, Matthias Brantner and Florent Georges,
            published by the <a href="http://w3.org/community/expath/">EXPath Community Group</a>
            under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community
               Contributor License Agreement (CLA)</a>. A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is
            available.</p><p class="copyright">This specification was published by the <a href="http://www.w3.org/community/expath/">EXPath Community Group</a>. It is not a W3C Standard nor is it on the W3C
            Standards Track. Please note that under the <a href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
               License Agreement (CLA)</a> there is a limited opt-out and other conditions apply.
            Learn more about <a href="http://www.w3.org/community/">W3C Community and Business
               Groups</a>.</p></div><hr /><div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2><p>This proposal provides an API for XPath 2.0 and XPath 3.0 to handle archive data (i.e.
            collected and possibly compressed sets of files and directories). It defines extension
            functions to process data from and to such archives files, including creation,
            determining and setting properties, listing and extracting contents and adding and
            updating entries. It has been designed to be compatible with XQuery 1.0 and XSLT 2.0, as
            well as any other XPath 2.0 usage. Some additional features for use in XPath 3.0 are
            also defined.</p></div><div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2><p class="toc">1 <a href="#status">Status of this document</a><br />
2 <a href="#introduction">Introduction</a><br />
    2.1 <a href="#d5e131">Namespace conventions</a><br />
    2.2 <a href="#d5e188">Error management</a><br />
    2.3 <a href="#type">Archive representation</a><br />
    2.4 <a href="#archive.types">Archive types</a><br />
3 <a href="#use-cases">Use cases</a><br />
    3.1 <a href="#example.epub">Creating a simple EPUB document</a><br />
    3.2 <a href="#example.jar">Examining a JAR file</a><br />
    3.3 <a href="#example.zip">Extracting a ZIP archive to a file system</a><br />
4 <a href="#descriptions">Describing archives and entries</a><br />
    4.1 <a href="#archive.properties">Archive properties and options</a><br />
    4.2 <a href="#entry.structures">Entry descriptions</a><br />
    4.3 <a href="#using.maps">Using map types to describe entries and options</a><br />
5 <a href="#loading">Loading and saving archives</a><br />
6 <a href="#information">Information about an archive and its contents</a><br />
    6.1 <a href="#options">arch:options</a><br />
    6.2 <a href="#entries">arch:entries</a><br />
7 <a href="#extraction">Extracting entries from an archive</a><br />
    7.1 <a href="#extract.binary">arch:extract-binary</a><br />
    7.2 <a href="#extract.text">arch:extract-text</a><br />
8 <a href="#updating">Updating entries in an archive</a><br />
    8.1 <a href="#delete">arch:delete</a><br />
    8.2 <a href="#update">arch:update</a><br />
9 <a href="#creating">Creating an archive</a><br />
    9.1 <a href="#create">arch:create</a><br />
10 <a href="#maps">Functions using XPath3.0 map() type</a><br />
    10.1 <a href="#archive.options.map">Archive property maps</a><br />
    10.2 <a href="#entry.structures.map">Entry property maps</a><br />
    10.3 <a href="#options.map">archM:options</a><br />
    10.4 <a href="#entries.map">archM:entries</a><br />
    10.5 <a href="#entry.names.map">archM:entry-names</a><br />
    10.6 <a href="#extractmap">archM:extract</a><br />
    10.7 <a href="#extract.binary.map">archM:extract-binary</a><br />
    10.8 <a href="#extract.text.map">archM:extract-text</a><br />
    10.9 <a href="#create.map">archM:create</a><br />
    10.10 <a href="#update.map">archM:update</a><br />
    10.11 <a href="#delete.map">archM:delete</a><br />
</p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3><p class="toc">A <a href="#references">References</a><br />
B <a href="#errors">Summary of error conditions</a><br />
</p></div><hr /><div class="body"><div class="div1">
<h2><a name="status" id="status"></a>1 Status of this document</h2><p>This document is in an interim draft stage. Comments are welcomed at <a href="mailto:public-expath@w3.org">public-expath@w3.org</a> mailing list (<a href="http://lists.w3.org/Archives/Public/public-expath/">archive</a>).</p></div><div class="div1">
<h2><a name="introduction" id="introduction"></a>2 Introduction</h2><div class="div2">
<h3><a name="d5e131" id="d5e131"></a>2.1 Namespace conventions</h3><p>The module defined by this document defines several functions, all contained in the
               namespace <code>http://expath.org/ns/archive</code>. In this document, the
                  <code>arch</code> prefix, when used, is bound to this namespace URI.</p><p>Alternative versions of these functions using the proposed XPath3.0
                  <code>map()</code> type (see <a href="#using.maps"><b>4.3 Using map types to describe entries and options</b></a>) are defined in the
               namespace <code>http://expath.org/ns/archive-map</code>. In this document, the
                  <code>archM</code> prefix, when used, is bound to this namespace URI. </p><p>Error codes are defined in the same namespace
                  (<code>http://expath.org/ns/archive</code>), and in this document are displayed
               with the same prefix, <code>arch</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This follows the suggestion (in late August 2013) for a coherent naming standard
                  in EXPath modules.</p></div><p>Binary file I/O, to read and write complete archives to files, uses facilities
               defined in the <a href="http://expath.org/spec/file">EXPath File Module</a>,
               which defines functions in the namespace <code>http://expath.org/ns/file</code>. In
               this document, the <code>file</code> prefix, when used, is bound to this namespace
               URI.</p><p>Manipulation of binary data itself can employ functions from <a href="http://expath.org/spec/binary">EXPath Binary Module</a>, which defines
               functions in the namespace <code>http://expath.org/ns/binary</code>. In this
               document, the <code>bin</code> prefix, when used, is bound to this namespace URI.</p></div><div class="div2">
<h3><a name="d5e188" id="d5e188"></a>2.2 Error management</h3><p>Error conditions are identified by a code (a <code>QName</code>.) When such an error
               condition is reached in the evaluation of an expression, a dynamic error is thrown,
               with the corresponding error code (as if the standard XPath function
                  <code>error()</code> had been called.)</p></div><div class="div2">
<h3><a name="type" id="type"></a>2.3 Archive representation</h3><p>Archives in this module are represented principally as items of type
                  <code>xs:base64Binary</code>, i.e. in their basic binary (byte sequence)
               forms.</p><p>Archives are treated as being arranged structurally as a description of overall
               options of the archive and a sequence of named entries. Each entry has:</p><ul><li><p>A <em>name</em> of the entry, which is treated as a sequence of Unicode
                     characters. In many cases the solidus character (<code>/</code>) is used to
                     imply the entries being logically arranged in positions within a directory
                     tree, but this is not mandatory.</p></li><li><p>A set of <em>properties</em> of the entry, denoting at least the
                     uncompressed size of the entry, archive internal properties for the entry, such
                     as the compression method used on the stored data and other indications such as
                     the date of last modification.</p></li><li><p>The <em>data</em> for the entry, treated as (possibly null) binary
                     data.</p></li></ul><p>It is most common that archives are considered to be arranged logically as
               directories, using the entry names to denote paths and file names (e.g.
                  <code>tests/qt3/archive/main.xml</code>) In such circumstances, archives may
               contain entries to represent the directories themselves (e.g.
                  <code>tests/qt3/archive/</code>) presumably with no data. [This could be used such
               that full extraction of an archive to a file system generates empty output
               directories for example.] This specification makes no distinction between these two
               cases - if an archive has an empty 'directory' entry it will be treated similarly to
               any other 'file' entry. <em>Semantic intrepretation of entry names as files in
                  directory trees is an application issue.</em></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Behaviour when entries with duplicate names are detected in an archive is
                  implementation dependent. Nevertheless, if an error is not thrown, only
                     <em>one</em> entry should be returned when reading. Implementations
                     <strong>must not</strong> write duplicate entries in result archives.</p></div></div><div class="div2">
<h3><a name="archive.types" id="archive.types"></a>2.4 Archive types</h3><p>The module is designed to be able to support a number of different types of archive,
               providing a coherent access mechanism.</p><p>The following archive types are required to be supported:</p><ul><li><p><a href="#zip">[ZIP]</a>: (which also covers derivative archive formats, such as JAR
                     or OpenDocument.)</p></li><li><p><a href="#gzip">[GZIP]</a> : A compressed archive of a sequence of files</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within GZIP names of entries (original file names) are optional, on a
                        per-file basis, so special measures may need to be taken to handle 'unnamed'
                        sections.</p></div></li></ul><p>Specific issues arise from i) archives used in streaming situations, where the
               internal manifests of the archives cannot be completed until all data is written, ii)
               archives where the order of entries is important, such as JAR, where the mainfest
               entries need to be first.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Currently there are no proposals within this module to cover encrypted
                  archives.</p></div></div></div><div class="div1">
<h2><a name="use-cases" id="use-cases"></a>3 Use cases</h2><p>Development of this specification was driven by requirements which some XML developers
            regularly encounter in examining or generating data which is presented in archival
            forms. Some typical use cases include:</p><ul><li><p>Manipulating EPUB documents.</p></li><li><p>Examining Java classes and resources stored in <code>JAR</code> formats.</p></li></ul><div class="div2">
<h3><a name="example.epub" id="example.epub"></a>3.1 Creating a simple EPUB document</h3><p>An <a href="#epub">[EPUB]</a> document is a collection of content sections, written in
               XHTML, with a metadata descriptor (usually the <code>content.opf</code> file) and a
               navigation description (usually the <code>toc.ncx</code> file), all collected
               together and potentially compressed in a ZIP format. A simple example of creating
               such a document in XQuery is:</p><div class="exampleInner"><pre>
arch:create(
    (
      { "name" : "mimetype", "compression" : "store" },
      "META-INF/container.xml",
      "OEBPS/content.opf",
      "OEBPS/Text/title.xhtml",
      "OEBPS/Text/chap01.xhtml",
      "OEBPS/toc.ncx"
    ),
    (
      content:mimetype(),
      content:metainf(),
      content:oebps-content(),
      content:title(),
      content:chapter(),
      content:toc()
    )
  )
</pre></div><p>The user-supplied XQuery function <code>content:mimetype()</code> returns the
               appropriate mimetype description for the EPUB document as a string
               ("application/epub+zip"). Each of the other <code>content:*()</code> functions
               generates a serialized form of the appropriate XML structure, e.g.:</p><div class="exampleInner"><pre>
declare function content:title() as xs:string
{
  fn:serialize(
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
      &lt;title&gt;Title Page&lt;/title&gt;
    &lt;/head&gt;
    
    &lt;body&gt;
      &lt;div&gt;
        &lt;h2 id="heading_id_2"&gt;Sample Book&lt;/h2&gt;
    
        &lt;h2 id="heading_id_3"&gt;A Sample .epub Book&lt;/h2&gt;
    
        &lt;h3 id="heading_id_4"&gt;Title Page&lt;/h3&gt;
      &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  )
};
</pre></div><p>Using a map struture to define an entry enables properties such as compression to be
               altered on on entry-by-entry basis. For and EPUB document the mimetype entry
                  <em>must</em> be uncompressed (so effectively it can be read by simple string
               searching), but other entries may be compressed.</p></div><div class="div2">
<h3><a name="example.jar" id="example.jar"></a>3.2 Examining a JAR file</h3><p>JAR files contain class code and definitions for Java classes, in entries whose names
               are <code><em>path/classname</em>.class</code>. Local classes (classes defined
               within a class) have separate code entries with a classname
                     <code><em>outerclass</em>$<em>innerclass</em></code>. To find all the
               main package-qualified classes the following XPath should suffice: </p><div class="exampleInner"><pre>
for $e in arch:entries(file:read-binary("lib/saxon9-sql.jar"))[ends-with(.,'.class') and not(contains(.,'$'))] 
  return replace(replace($e,'\.class$',''),'/','.')
=&gt; 
   "net.sf.saxon.option.sql.SQLClose", 
   "net.sf.saxon.option.sql.SQLColumn", 
   "net.sf.saxon.option.sql.SQLConnect",
   ....,
   "net.sf.saxon.option.sql.SQLUpdate" 
</pre></div></div><div class="div2">
<h3><a name="example.zip" id="example.zip"></a>3.3 Extracting a ZIP archive to a file system</h3><p>Assuming the ZIP file in question has (empty) entries denoting any directories
               required, the following XSLT will unzip an archive to the current directory, using
               the file writing functions of <a href="#expathfile">[EXPathFile]</a>: </p><div class="exampleInner"><pre>
&lt;xsl:variable name="arch" select="file:read-binary($uri)"/&gt;
&lt;xsl:variable name="entries" select="arch:entries($arch)"/&gt;
&lt;xsl:variable name="dirs" select="$entries[ends-with(.,'/')]"/&gt;
&lt;xsl:variable name="required.dirs"
            select="for $r in distinct-values(($entries except $dirs) return
            replace($r,'/[^/]+$','/'))[ends-with(.,'/')]"/&gt;
&lt;xsl:sequence select="for $d in distinct-values(($required.dirs,$dirs))
         return file:create-dir(replace($d,'/$',''))"/&gt;
&lt;xsl:sequence select="for $f in ($entries except $dirs) 
        return file:write-binary($f,arch:extract-binary($arch,$f))"/&gt;
</pre></div><p>(<code>file:create-dir()</code> creates necessary intermediate directories, so
                  <code>$dirs</code> does not need to be in a sorted order. If the ZIP archive does
                  <em>not</em> have entries for all directories, further intermediate code is
               required to identify those missing.)</p></div></div><div class="div1">
<h2><a name="descriptions" id="descriptions"></a>4 Describing archives and entries</h2><p>The properties of overall archives and individual entries at the XDM level are described
            by small structured elements, with optional information attached. <em>In this proposal
               this information is attached as attributes.</em></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Parallels with XPath 3.0 serialization parameters, which are now sets of (element)
               nodes, become awkward. In <code>arch:entry</code> we would need to add an element
                  <code>arch:name</code> to hold the name of an entry, rather than rely on the
               string value. The major point in favour of using elements rather than attributes
               would be where we need to read or set complex structured parameters, such as
               character maps. This needs discussion.</p></div><div class="div2">
<h3><a name="archive.properties" id="archive.properties"></a>4.1 Archive properties and options</h3><p>Archive options and properties are described as a structured element
                  (<code>element(arch:options)</code>) with the following attributes:</p><ul><li><p><code>format</code>: the type of the archive, e.g. "zip". This is
                     mandatory.</p></li><li><p><code>algorithm</code>: the default compression used in the archive, e.g.
                     "deflate".</p></li></ul><p>Other attributes may be dependent upon the type of the archive and the
               implementation.</p></div><div class="div2">
<h3><a name="entry.structures" id="entry.structures"></a>4.2 Entry descriptions</h3><p>Entries within the archive can be accessed by name (<code>xs:string</code>) or a
               structured element (<code>element(arch:entry)</code>). In the latter case the entry
               name is the string value of the element.</p><p>When describing an existing entry in an archive, <code>element(arch:entry)</code> may
               be returned with the following optional attributes:</p><ul><li><p><code>size</code>: the original file size of the entry.</p></li><li><p><code>compressed-size</code>: the compressed file size of the entry, i.e. the
                     number of bytes it occupies in the archive.</p></li><li><p><code>last-modified</code>: the date of last modification of this entry, in
                        <code>xs:dateTime</code> notation.</p></li><li><p><code>compression-level</code>: an indicator of the level of (lossless?)
                     compression.</p></li></ul><p>When used to create or update an entry in an archive,
                  <code>element(arch:entry)</code> may also have the following optional
               attributes:</p><ul><li><p><code>last-modified</code>: the date of last modification to be written on this
                     entry, in <code>xs:dateTime</code> notation.</p></li><li><p><code>compression-level</code>: the level of (lossless?) compression to be used
                     in writing the entry into the archive.</p></li><li><p><code>encoding</code>: the encoding to be used for converting textual items to
                     a byte sequence, prior to possible compression and writing to the archive.</p></li></ul><p>(In writing actions, unknown attributes are ignored.)</p></div><div class="div2">
<h3><a name="using.maps" id="using.maps"></a>4.3 Using map types to describe entries and options</h3><p>Proposals in XPath 3.0 have been made for a type
                  <code>map(xs:untypedAtomic,item()*)</code>, which could be exploited beneficially
               for manipulating archives, using the entry name as the key and the
                  (<code>xs:base64Binary</code>) value of the entry as the corresponding value in
               the map. These maps could be used both as output (in <code>arch:entries()</code> and
                  <code>arch:extract-[text|binary]()</code>) or for input (in
                  <code>arch:update()</code> and <code>arch:create()</code>). Equally well such maps
               can be used, reading keys only in <code>arch:delete()</code>.</p><p>An attractive alternative would be for each entry itself to be a <code>map($property
                  as xs:string, $value as item()*)</code>, with suitable keys, e.g.
                  <code>content</code> -&gt; <code>xs:base64Binary</code>. Thus the entry 'set' can be
               a map <code>map(xs;string, map(xs:string,item()*))</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Functions using such maps for arguments and results could either have separate
                  names (e.g. <code>arch:entries-as-map()</code>) or be defined in a separate
                  namespace (<code>archM:entries()</code>) - in this current draft the second is
                  used. Details are discussed in <a href="#maps"><b>10 Functions using XPath3.0 map() type</b></a></p></div><p>Support for similar approaches using other map representations, such as <a href="#jsoniq">[JSONiq]</a> objects may be implementation dependent.</p></div></div><div class="div1">
<h2><a name="loading" id="loading"></a>5 Loading and saving archives</h2><p>This module defines no specific functions for reading and writing archives from files,
            as distinct from their binary data. The EXPath File Module <a href="#expathfile">[EXPathFile]</a>
            provides two suitable functions to do this:</p><ul><li><p>
                  <code class="function"><a href="http://expath.org/spec/file#d3e954">file:read-binary</a></code>($file as <code class="type">xs:string</code>) as
                     <code class="type">xs:base64Binary</code>. Returns the content of a file in its Base64
                  representation.</p></li><li><p>
                  <code class="function"><a href="http://expath.org/spec/file#d3e1359">file:write-binary</a></code>($file as <code class="type">xs:string</code>,
                  $value as <code class="type">xs:base64Binary</code>) as
                     <code class="type">empty-sequence()</code>. Writes a Base64 item as binary to a file.
               </p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>There may be some desire for some convenience functions <code>arch:write($file as
                     <code class="type">xs:string</code>,....) as empty-sequence()</code> which does
               creation and file writing as one action.</p></div></div><div class="div1">
<h2><a name="information" id="information"></a>6 Information about an archive and its contents</h2><div class="div2">
<h3><a name="options" id="options"></a>6.1 arch:options</h3><dl><dt class="label">Summary</dt><dd><p>Returns a description of the type and properties of a given archive. </p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:options</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">element(arch:options)*</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>The description is returned as an element <code>&lt;arch:options&gt;</code> with an
            unordered sequence of child elements describing the details. The following are currently
            supported:</p><ul><li><code>arch:format</code>: format of this archive</li><li><code>arch:algorithm</code>: the compression algorithm that was used.</li></ul><p>If the archive format supports a compression algorithm varying on a per-entry basis, and
            more than one algorithm has been used in the archive, <code>mixed</code> is returned for
               <code>arch:algorithm</code>.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem in
            reading the archive.</p></dd><dt class="label">Examples</dt><dd><p>Finding the properties of the archive stored in a file located at
               <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:options(file:read-binary($uri))
=&gt; &lt;arch:options&gt;
     &lt;arch:format&gt;ZIP&lt;/arch:format&gt;
     &lt;arch:algorithm&gt;deflate&lt;/arch:algorithm&gt;
   &lt;/arch:options&gt;</pre></div></dd></dl></div><div class="div2">
<h3><a name="entries" id="entries"></a>6.2 arch:entries</h3><dl><dt class="label">Summary</dt><dd><p>Returns the set of entry descriptors for all the entries found within the archive. </p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:entries</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">element(arch:entry)*</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>Each descriptor is an element <code>&lt;arch:entry&gt;</code> whose text value is the
            path of the file within the archive. For more details of this structure see <a href="#entry.structures"><b>4.2 Entry descriptions</b></a>.</p><p>The entries are returned in the order in which they encountered serially within the
            archive.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>There may be a case for providing a sorted version, probably using some form of
            collation.</p></dd><dt class="label">Examples</dt><dd><p>Finding the entries of the archive stored in a file located at <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:entries(file:read-binary($uri))
=&gt; &lt;arch:entry size="2194" compressed-size="652" last-modified="2013-07-18T11:22:12"&gt;build.xml&lt;/arch:entry&gt;
   &lt;arch:entry size="84983" compressed-size="84872" last-modified="2009-03-23T11:15:06"&gt;lumley.jpg&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </pre></div><p>Counting the number of apparent XML files in the previous example:</p><div class="exampleInner"><pre>
count(arch:entries(file:read-binary($uri))[ends-with(.,'.xml')])
=&gt; 2
     </pre></div></dd></dl></div></div><div class="div1">
<h2><a name="extraction" id="extraction"></a>7 Extracting entries from an archive</h2><p>The module does not attempt to discern the 'type' of an entry (such as 'text', 'XML',
            'raw-binary'), leaving that to the programmer. Two forms of reading result are
            supported: raw binary (<code>xs:base64Binary</code>) and decoded text
               (<code>xs:string</code>). </p><div class="div2">
<h3><a name="extract.binary" id="extract.binary"></a>7.1 arch:extract-binary</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as binary data.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-binary</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary*</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns as binary data each entry in the archive <code>$in</code> that corresponds to
            the entry name input, in sequence.</p><p>The entries <strong>must</strong> be returned in the order corresponding to that of
            the entries requested in <code>$entries</code>, not in the order in which they may exist
            in the archive.</p><p>Multiple requests for the same entry will be honoured, with copies of the entry
            appearing in corresponding multiple locations in the output sequence .</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist in
            this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>There have been suggestions for a signature <code>arch:extract-binary($archive as
               xs:base64Binary)</code> returning all the entries. In the absence of maps in the
            return type, this does not make sense, since the entries are totally unlabelled, and to
            get anything meaningful, a parallel call on <code>arch:entries()</code> would be
            required.</p></dd><dt class="label">Examples</dt><dd><p>Returning the binary data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:extract-binary(file:read-binary($uri),'build.xml')
=&gt; stuff
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="extract.text" id="extract.text"></a>7.2 arch:extract-text</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as strings. If
               <code>$encoding</code> is specified the strings are decoded appropriately, otherwise
            UTF-8 encoding is assumed.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns as a string each entry in the archive <code>$in</code> that corresponds to the
            entry name input, in sequence.</p><p>If <code>$encoding</code> is specified the strings are decoded appropriately, otherwise
            UTF-8 encoding is assumed.</p><p>The entries <strong>must</strong> be returned in the order corresponding to that of
            the entries requested in <code>$entries</code>, not in the order in which they may exist
            in the archive.</p><p>Multiple requests for the same entry will be honoured, with copies of the entry
            appearing in corresponding multiple locations in the output sequence .</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist in
            this archive.</p><p><a href="#error.unknownEncoding">[arch:unknown-encoding]</a> is raised if the encoding requested is unknown or
            unsupported.</p><p><a href="#error.decoding">[arch:decoding-error]</a> is raised if there was an error in decoding the
            entry.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>This function should be equivalent to the use of <code>arch:extract-binary()</code> and
            the function <code>bin:decode-string()</code> from <a href="#expathbinary">[EXPathBinary]</a>:</p><div class="exampleInner"><pre>arch:extract-binary($in,$entries) ! bin:decode-string(.,$encoding) [XPath 3.0]</pre></div><div class="exampleInner"><pre>for $b in arch:extract-binary($in,$entries) return bin:decode-string($b,$encoding)
            [XPath 2.0]</pre></div><p>Further conversion into XML can be achieved using the XPath3.0 function
               <code>fn:parse-XML()</code> on each of the returned strings.</p><p>There have been suggestions for a signature <code>arch:extract-text($archive as
               xs:base64Binary)</code> returning all the entries. In the absence of maps in the
            return type, this does not make sense, since the entries are totally unlabelled, and to
            get anything meaningful, a parallel call on <code>arch:entries()</code> would be
            required.</p></dd><dt class="label">Examples</dt><dd><p>Returning the text data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:extract-text(file:read-binary($uri),'build.xml','UTF-8')
=&gt; stuff
     </pre></div></dd></dl></div></div><div class="div1">
<h2><a name="updating" id="updating"></a>8 Updating entries in an archive</h2><p>There are two atomic actions available to change entries within an archive: complete
            deletion of an entry, or complete updating (overwriting) of that entry - the latter adds
            new entries when the given name does not already exist in the archive</p><div class="div2">
<h3><a name="delete" id="delete"></a>8.1 arch:delete</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with the given entries deleted.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">arch:delete</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <code>$in</code> with all the entries named in
               <code>$entries</code> deleted.</p><p>The relative order of the remaining entries within the archive is preserved.</p><p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p><p>Duplicate entries in <code>$entries</code> are ignored.</p><p>If <code>$entries</code> is the empty sequence, the original archive shall be
            returned.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested for deletion does not
            exist in this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>Whilst the uncompressed entries remaining after deletion should of course be the same
            size and content as those before deletion, depending upon the (lossless) compression
            algorithm used, the compressed sizes and content might not be. In the absence of a
            special check, in these circumstances <code>$in</code> may not be identical to
               <code>arch:delete($in,())</code>. This needs discussion. </p></dd><dt class="label">Examples</dt><dd><p>Deleting the entries of the archive stored in a file located at
               <code>$uri</code>:</p><div class="exampleInner"><pre>
arch:entries(arch:delete(file:read-binary($uri),'lumley.jpg'))
=&gt; &lt;arch:entry size="2194" compressed-size="652" last-modified="2013-07-18T11:22:12"&gt;build.xml&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="update" id="update"></a>8.2 arch:update</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with each of the given entries in <code>$entries</code> updated to
            the corresponding values in the sequence <code>$new</code>. If an entry is not found, a
            new entry is added to the end of the archive.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:update</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$new</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="4"><code class="function">arch:update</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$new</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$last-modified</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:dateTime</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <code>$in</code> with each of the given entries
            in <code>$entries</code> updated to the corresponding value in the sequence
               <code>$new</code>. If an entry is not found, a new entry for it is added to the end
            of the archive.</p><p>The relative order of all the existing and replaced entries within the archive is
            preserved. New entries appear at the end of the archive in the order in which they were
            specified in the call.</p><p>If specified, and the format supports it, the last-modified date for each of the updated
            entries will be set to <code>$last-modified</code>. In the absence of such a parameter,
            it is implementation-dependent whether last-modified information will be written on the
            updated entries. If such default last-modification is written, it should be comparable
            to the value of <code>fn:current-dateTime()</code> in an XSLT environment.</p><p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p><p>The compression methods of the updated entries shall be preserved.</p><p>When duplicate names appear in the entry list, the value of the entry in the resulting
            archive will be that of the value of <code>$new</code> corresponding to the
               <em>last</em> matching entry name. </p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.entryDataMismatch">[arch:entry-data-mismatch]</a> is raised if <code>count($entries) ne
               count($new)</code>.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading or creating the archive.</p></dd></dl></div></div><div class="div1">
<h2><a name="creating" id="creating"></a>9 Creating an archive</h2><p>new archives need to be created </p><div class="div2">
<h3><a name="create" id="create"></a>9.1 arch:create</h3><dl><dt class="label">Summary</dt><dd><p>Returns a new archive with each of the given entries in <code>$entries</code> set to the
            corresponding values in the sequence <code>$new</code>.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">arch:create</code>(<code class="arg">$entries</code><code class="as"> as </code><code class="type">xs:string*</code>, <code class="arg">$new</code><code class="as"> as </code><code class="type">xs:base64Binary*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">arch:create</code>(</td><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$new</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$options</code></td><td valign="baseline"><code class="as"> as </code><code class="type">element(arch:options)</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of format specified by <code>$options</code> with each of the given
            entries in <code>$entries</code> set to the corresponding value in the sequence
               <code>$new</code>.</p><p>The relative order of new entries within the archive follows that of the input.</p><p>When duplicate names appear in the entry list, the value of the entry in the resulting
            archive will be that of the value of <code>$new</code> corresponding to the
               <em>last</em> matching entry name. </p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.entryDataMismatch">[arch:entry-data-mismatch]</a> is raised if <code>count($entries) ne
               count($new)</code>.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading or creating the archive.</p></dd></dl></div></div><div class="div1">
<h2><a name="maps" id="maps"></a>10 Functions using XPath3.0 map() type</h2><p>Maps proposed for XPath3.0 can increase the coherence of the functions in the module,
            mainly by retaining the structured connection between the entry name and its properties
            and content. In addition the properties of the overall archive (and its defaults for new
            entries) can similarly be defined in a single map.</p><p>This section proposes parallel functions to those above using maps.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><code>map:keys($map as map(*)) as xs:anyAtomicType*</code> returns the keys that are
               present in a map, in unpredictable order. This means that if order within an archive
               is important (either in extraction or updating) other mechanisms may be needed.</p><p>In general when using maps for denoting the entries to be manipulated, the arguments
               might be considered to be a (possibly empty) sequence of maps that are treated as if
               concatentated. [THIS NEEDS THOUGHT ABOUT OVERWRITING/MERGING COMMON KEYS]</p></div><div class="div2">
<h3><a name="archive.options.map" id="archive.options.map"></a>10.1 Archive property maps</h3><p>Using a reserved name within the overall map (such as <code>arch:options</code>)
               would allow the options/properties for an archive to be stored alongside the
               entries.</p></div><div class="div2">
<h3><a name="entry.structures.map" id="entry.structures.map"></a>10.2 Entry property maps</h3><p>Entries within the archive can be also be accessed or described by entries in a map
                  (<code>map(xs:string,map(xs:string,item()*))</code>). In this case the map key
               gives the (path)name of the archive entry (e.g. <code>build/build-j.xml</code>) and
               the value is a map of the properties of that entry.</p><p>The following keys are provided when reporting on entries:</p><ul><li><p><code>size</code>: the original file size of the entry as
                        <code>xs:integer</code></p></li><li><p><code>compressed-size</code>: the compressed file size of the entry as
                        <code>xs:integer</code>, i.e. the number of bytes it occupies in the
                     archive.</p></li><li><p><code>last-modified</code>: the date of last modification of this entry, in
                        <code>xs:dateTime</code> notation</p></li><li><p><code>compression-level</code>: an indicator of the level of (lossless?)
                     compression.</p></li><li><p><code>content</code>: the value of the entry read from the archive, as
                        <code>xs:base64Binary</code>. This will only be set if
                        <code>$return-content</code> is requested in the call to
                        <code>archM:entries()</code>.</p></li></ul><p>When used to extract an entry from an archive, this map may have the following
               optional key/value pairs:</p><ul><li><p><code>encoding</code>: the encoding to be used for converting textual items
                     from a byte sequence.</p></li></ul><p>When used to create or update an entry in an archive, this map may have the following
               optional key/value pairs:</p><ul><li><p><code>content</code>: the value of the entry to be written in the archive,
                     either as <code>xs:base64Binary</code> or, when <code>encoding</code> is set,
                     as <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><em>This is awkward - why not just insist on <code>xs:base64Binary</code>
                           and let the programmer encode?</em></p></div></li><li><p><code>last-modified</code>: the date of last modification to be written on this
                     entry, in <code>xs:dateTime</code> notation</p></li><li><p><code>compression-level</code>: the level of (lossless?) compression to be used
                     in writing the entry into the archive.</p></li><li><p><code>encoding</code>: the encoding to be used for converting textual items to
                     a byte sequence, prior to possible compression and writing to the archive.</p></li></ul></div><div class="div2">
<h3><a name="options.map" id="options.map"></a>10.3 archM:options</h3><dl><dt class="label">Summary</dt><dd><p>Returns a description of the type and properties of a given archive as a map. </p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">archM:options</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">map(xs:string,item()?)</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>The description is returned as a map <code>map(xs:string,item()?)</code> with entries
            describing the details. The following are currently supported:</p><ul><li><code>format</code>: format of this archive</li><li><code>compression</code>: the compression algorithm that was used.</li></ul><p>If the archive format supports a compression algorithm varying on a per-entry basis, and
            more than one algorithm has been used in the archive, <code>mixed</code> is returned for
            the <code>compression</code> entry.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem in
            reading the archive.</p></dd><dt class="label">Examples</dt><dd><p>Finding the properties of the archive stored in a file located at
               <code>$uri</code>:</p><div class="exampleInner"><pre>
archM:options(file:read-binary($uri))
=&gt; {'format' :'zip', 'compression' : 'deflate'}
</pre></div></dd></dl></div><div class="div2">
<h3><a name="entries.map" id="entries.map"></a>10.4 archM:entries</h3><dl><dt class="label">Summary</dt><dd><p>Returns the entry descriptors for all the entries found within the archive as a map,
            optionally each with their content.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline"><code class="function">archM:entries</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">map(xs:string,map(xs:string,item()*))</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:entries</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$return-content</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:boolean</code>)<code class="as"> as </code><code class="return-type">map(xs:string,map(xs:string,item()*))</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Keys to the returned map are the entry (path) names.</p><p>The value for each map entry is a map describing the properties of that entry. For more
            details of this structure see <a href="#entry.structures.map"><b>10.2 Entry property maps</b></a>.</p><p>If <code>$return-content</code> is defined and equals <code>true()</code>, then the
            content for each entry is returned as the <code>content</code> entry in the property
            map, as a <code>xs:base64Binary</code> item.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>As the returned order of keys from <code>map:keys()</code> is not defined and can be
            implementation-dependant, there may be a need for a simple function
               (<code>archM:entry-names(xs:base64Binary) as xs:string*)</code> which returns purely
            the names <em>in the order in which they appear in the archive.</em></p><p>Using <code>$return-content</code> makes it possible to return a complete archive in a
            single call. <em>(What about the archive options?</em></p></dd><dt class="label">Examples</dt><dd><p>Finding the entries of the archive stored in a file located at <code>$uri</code>:</p><div class="exampleInner"><pre>
archM:entries(file:read-binary($uri))
=&gt; map{ 
  "build.xml" := map{ "size":=2194, "compressed-size":=652, "last-modified":="2013-07-18T11:22:12"},
  "lumley.jpg" := map{ "size":=84983, "compressed-size":=84872, "last-modified":="2009-03-23T11:15:06"},
  "tests/qt3/binary/binary.xml" := map{ "size":=10058, "compressed-size":=1381, "last-modified":="2013-08-06T13:14:08"}}
     </pre></div><p>Counting the number of apparent XML files in the previous example:</p><div class="exampleInner"><pre>
count(map:keys(archM:entries(file:read-binary($uri)))[ends-with(.,'.xml')])
=&gt; 2
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="entry.names.map" id="entry.names.map"></a>10.5 archM:entry-names</h3><dl><dt class="label">Summary</dt><dd><p>Returns the entry names for all the entries found within the archive as a sequence of
            string values in the order in which they appear in the archive.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><code class="function">archM:entry-names</code>(<code class="arg">$archive</code><code class="as"> as </code><code class="type">xs:base64Binary</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns the entry names for all the entries found within the archive as a sequence of
            string values in the order in which they appear in the archive.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there is an unspecified problem in
            reading the archive.</p></dd></dl></div><div class="div2">
<h3><a name="extractmap" id="extractmap"></a>10.6 archM:extract</h3><dl><dt class="label">Summary</dt><dd><p>Returns a copy of <code>$entries</code> with the content entries set to binary or
            decoded string data for the appropriate entry in the archive.</p></dd><dt class="label">Signature</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>)<code class="as"> as </code><code class="return-type">map(xs:string,map(xs:string,item()?))</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>The map entries in <code>$entries</code> define whether binary or decoded string data is
            to be returned.</p><p>The behaviour of this function is defined by equivalent XPath:</p><div class="exampleInner"><pre>
map:new(for $k in map:keys($entries) 
   return 
     let $a := $entries($k),
         $text := map:contains($a,'encoding'),
         $encoding := ($a('encoding'),'UTF-8')[1],
         $data := arch:extract-binary($archive,$k) // error if not found
     return 
         map:entry($k,
             map:new(($a,
               map:entry('content',if($text) bin:decode-string($data,$encoding) else $data)
               ))
       )
     </pre></div></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist in
            this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Examples</dt><dd><p>To collect all the XML entries as XML:</p><div class="exampleInner"><pre>
let $archive := file:read-binary($uri)
    $entries := archM:entries($archive),
    $xml-names := map:keys($entries)[ends-with(.,'.xml')],
    $get := map:new($xml-names ! map:entry(.,map:entry('encoding','UTF-8'))),
    $content := archM:extract($archive,$get)
return
    $xml-names ! fn:parse-XML($content(.)('content'))
     </pre></div></dd></dl></div><div class="div2">
<h3><a name="extract.binary.map" id="extract.binary.map"></a>10.7 archM:extract-binary</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as binary data.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract-binary</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract-binary</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary*</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns as binary data each entry in the archive <code>$in</code> that corresponds to
            the entry name input, or <code>map:keys($entries)</code>, in sequence.</p><p>When <code>$entries</code> has type <code>xs:string*</code>, the entries
               <strong>must</strong> be returned in the order corresponding to that of the entries
            requested in <code>$entries</code>, not in the order in which they may exist in the
            archive.</p><p>When <code>$entries</code> has type <code>xs:string*</code>, multiple requests for the
            same entry will be honoured, with copies of the entry appearing in corresponding
            multiple locations in the output sequence .</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist in
            this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>Collection of all the entries as binary data can be accomplished using
               <code>archM:entries($archive,true())</code> and collecting the <code>'content'</code>
            entry from each of the returned maps.</p><p>The signatures with <code>$entries instance of xs:string*</code> are equivalent to
               <code>arch:extract-binary()</code>.</p></dd></dl></div><div class="div2">
<h3><a name="extract.text.map" id="extract.text.map"></a>10.8 archM:extract-text</h3><dl><dt class="label">Summary</dt><dd><p>Returns the sequence of requested entries from the archive as decoded string data.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">archM:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">archM:extract-text</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$encoding</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">xs:string*</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns as decoded string data each entry in the archive <code>$in</code> that
            corresponds to the entry name input, or <code>map:keys($entries)</code>, in
            sequence.</p><p>When <code>$entries</code> has type <code>xs:string*</code>, the entries
               <strong>must</strong> be returned in the order corresponding to that of the entries
            requested in <code>$entries</code>, not in the order in which they may exist in the
            archive.</p><p>When <code>$entries</code> has type <code>xs:string*</code>, multiple requests for the
            same entry will be honoured, with copies of the entry appearing in corresponding
            multiple locations in the output sequence.</p><p>If <code>$encoding</code> is specified, or the field <code>'decoding'</code> appears in
            the entry in <code>$entries</code>, the strings are decoded according to that encoding,
            otherwise UTF-8 encoding is assumed.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested does not exist in
            this archive.</p><p><a href="#error.unknownEncoding">[arch:unknown-encoding]</a> is raised if an encoding requested is unknown or
            unsupported.</p><p><a href="#error.decoding">[arch:decoding-error]</a> is raised if there was an error in decoding an entry.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>The signatures with <code>$entries instance of xs:string*</code> are equivalent to
               <code>arch:extract-text()</code>.</p></dd></dl></div><div class="div2">
<h3><a name="create.map" id="create.map"></a>10.9 archM:create</h3><dl><dt class="label">Summary</dt><dd><p>Returns a new archive with each of the given entries named as a key in
               <code>$entries</code> set to the corresponding value in
               <code>$entries($key)('content')</code>.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline"><code class="function">archM:create</code>(</td><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:create</code>(</td><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))*</code>,</td></tr><tr><td valign="baseline"><code class="arg">$options</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,item())</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of format specified by <code>$options</code> with each of the given
            entries named as a key in <code>$entries</code> set to the corresponding value in
               <code>$entries($key)('content')</code>..</p><p>The relative order of new entries within the archive follows that of the input.</p><p>If <code>$options</code> is specified, the overall archive properties (and defaults for
            the entries) are set to those specified in the map.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            creating the archive.</p></dd></dl></div><div class="div2">
<h3><a name="update.map" id="update.map"></a>10.10 archM:update</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with each of the given entries in the keys of <code>$entries</code>
            updated to the corresponding values in the <code>$entries($key)('content')</code> and
            with other properties defined by <code>$entries($key)(*)</code>. If an entry is not
            found, a new entry is added to the end of the archive.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:update</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="3"><code class="function">archM:update</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()?))</code>,</td></tr><tr><td valign="baseline"><code class="arg">$default</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,item())</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive with each of the given entries in the keys of <code>$entries</code>
            updated to the corresponding values in the <code>$entries($key)('content')</code> and
            with other properties defined by <code>$entries($key)(*)</code>. If an entry is not
            found, a new entry is added to the end of the archive.</p><p>If <code>$options</code> is specified, values will be used for the default properties
            for each entry, which may be overloaded by the property map for each individual
            entry.</p><p>The relative order of all the existing and replaced entries within the archive is
            preserved. New entries appear at the end of the archive in the order in which they were
            specified in the call.</p><p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p><p>The compression methods of the updated entries shall be preserved.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading or creating the archive.</p></dd><dt class="label">Notes</dt><dd><p>Using the <code>$default</code> map a common compression method, last-modification date
            and similar can be set for a set of entries, whose minimal map entries are
               <code>map{"content":=$content}</code>
         </p></dd></dl></div><div class="div2">
<h3><a name="delete.map" id="delete.map"></a>10.11 archM:delete</h3><dl><dt class="label">Summary</dt><dd><p>Returns an archive with the given entries deleted.</p></dd><dt class="label">Signatures</dt><dd><p><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:delete</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:string*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div><div xmlns="" class="exampleInner"><div class="proto"><table border="0" cellpadding="0" cellspacing="0" summary="Function prototype"><tr><td valign="baseline" rowspan="2"><code class="function">archM:delete</code>(</td><td valign="baseline"><code class="arg">$archive</code></td><td valign="baseline"><code class="as"> as </code><code class="type">xs:base64Binary</code>,</td></tr><tr><td valign="baseline"><code class="arg">$entries</code></td><td valign="baseline"><code class="as"> as </code><code class="type">map(xs:string,map(xs:string,item()))*</code>)<code class="as"> as </code><code class="return-type">xs:base64Binary</code></td></tr></table></div></div></p></dd><dt class="label">Rules</dt><dd><p>Returns an archive of the same format as <code>$in</code> with all the entries named in
               <code>$entries</code> or <code>$entries!map:keys(.)</code> deleted.</p><p>The relative order of the remaining entries within the archive is preserved.</p><p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p><p>Duplicate entries in <code>$entries</code> are ignored.</p><p>If <code>$entries</code> is the empty sequence, or an empty map, the original archive
            shall be returned.</p></dd><dt class="label">Error Conditions</dt><dd><p><a href="#error.unknownEntry">[arch:unknown-entry]</a> is raised if an entry requested for deletion does not
            exist in this archive.</p><p><a href="#error.archiveReadError">[arch:read-error]</a> is raised if there was an unspecified problem in
            reading the archive.</p></dd><dt class="label">Notes</dt><dd><p>Whilst the uncompressed entries remaining after deletion should of course be the same
            size and content as those before deletion, depending upon the (lossless) compression
            algorithm used, the compressed sizes and content might not be. In the absence of a
            special check, in these circumstances <code>$in</code> may not be identical to
               <code>arch:delete($in,())</code>. This needs discussion. </p><p>The signature with <code>$entries as xs:string*</code> is defined as a convenience, to
            avoid the creation of a simple map. Otherwise it is completely analagous to
               <code>arch:delete(xs:base64Binary,xs:string*)</code>.</p></dd></dl></div></div></div><div class="back"><div class="div1">
<h2><a name="references" id="references"></a>A References</h2><dl><dt class="label"><a name="epub" id="epub"></a>EPUB</dt><dd>
               <a href="http://www.idpf.org/epub/30/spec/epub30-overview.html">EPUB 3
                  Overview</a>. International Digital Publishing Forum. Recommended Specification
               11 October 2011.</dd><dt class="label"><a name="expathfile" id="expathfile"></a>EXPathFile</dt><dd>
               <a href="http://expath.org/spec/file">File Module</a>. Christian Grün and
               Matthias Brantner, editors. EXPath Candidate Module. 14 June 2012.</dd><dt class="label"><a name="expathbinary" id="expathbinary"></a>EXPathBinary</dt><dd>
               <a href="http://expath.org/spec/binary">Binary Module</a>. Jirka Kosek and John
               Lumley, editors. EXPath Candidate Module. 6 August 2013.</dd><dt class="label"><a name="fo30" id="fo30"></a>F&amp;O 3.0</dt><dd>
               <a href="http://www.w3.org/TR/xpath-functions-30/">XPath and XQuery Functions and
                  Operators 3.0</a>. Michael Kay, editor. W3C Candidate Recommendation 21 May
               2013.</dd><dt class="label"><a name="gzip" id="gzip"></a>GZIP</dt><dd>
               <a href="http://www.gzip.org/zlib/rfc-gzip.html">GZIP file format specification
                  version 4.3</a>. L. Peter Deutsch, 1996.</dd><dt class="label"><a name="jsoniq" id="jsoniq"></a>JSONiq</dt><dd>
               <a href="http://www.jsoniq.org/">JSONiq - The JSON Query Language</a>. FLWOR
               Foundation. 2013.</dd><dt class="label"><a name="xmlschema1.1" id="xmlschema1.1"></a>XML Schema 1.1 Part 2</dt><dd>
               <a href="http://www.w3.org/TR/xmlschema11-2/">W3C XML Schema Definition Language
                  (XSD) 1.1 Part 2: Datatypes</a>. David Peterson et al, editors.W3C
               Recommendation 5 April 2012.</dd><dt class="label"><a name="zip" id="zip"></a>ZIP</dt><dd>
               <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">ZIP File Format
                  Specification</a>.PKWare, Version 6.3.3, 1 September 2012.</dd></dl></div><div class="div1">
<h2><a name="errors" id="errors"></a>B Summary of error conditions</h2><dl><dt class="label"><a name="error.archiveReadError" id="error.archiveReadError"></a>arch:read-error</dt><dd>There was an general error in
               reading the archive</dd><dt class="label"><a name="error.unknownEntry" id="error.unknownEntry"></a>arch:unknown-entry</dt><dd>The specified entry does not
               exist in this archive.</dd><dt class="label"><a name="error.entryDataMismatch" id="error.entryDataMismatch"></a>arch:entry-data-mismatch</dt><dd>The sequence of entry
               names is not the same length as the sequence of updated values.</dd><dt class="label"><a name="error.unknownEncoding" id="error.unknownEncoding"></a>arch:unknown-encoding</dt><dd>The specified encoding is
               not supported.</dd><dt class="label"><a name="error.decoding" id="error.decoding"></a>arch:decoding-error</dt><dd>Error in decoding a string.</dd></dl></div></div><script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
         </script><script type="text/javascript">
            try {
               var pageTracker = _gat._getTracker("UA-5463082-2");
               pageTracker._trackPageview();
            } catch(err) {}
         </script></body></html>